---
title: ðŸ’ª Using Hooks
description: Hooks allow you to hook into the request lifecycle with powerful helper methods.
---

<Callout title="Looking for interceptors?" type="warn">
You want to hook into some lifecycle, great, they're called hooks!
</Callout>

Hooks are a powerful feature that allow you to hook into the request lifecycle in order to intercept it and modify the request or response. Hooks can be used to implement features such as authentication, logging, custom caching, error handling, and more.

This is a common pattern in fetch libraries and so you can use it in kinda similar use cases.

## âœ¨ New Simplified Hooks API

Z-Fetch now provides **intuitive helper methods** to make hooks much easier to work with, eliminating complex spreading patterns:

### Helper Methods Available

- `setHeaders(updater)` - Easily modify headers
- `setBody(body)` - Set request body  
- `setOptions(updater)` - Update request options
- `setUrl(url)` - Change request URL
- `setMethod(method)` - Modify HTTP method
- `setError(error)` - Set or modify errors (onError hook only)

### Before vs After

**Before (Complex spreading):**
```js
onRequest: async (context) => {
  return {
    request: {
      ...context.request,
      options: {
        ...context.request.options,
        headers: { 
          ...context.request.options.headers, 
          'X-Custom': 'value' 
        }
      }
    }
  };
}
```

**After (Simple helpers):**
```js
onRequest: async (context) => {
  context.setHeaders(headers => ({ ...headers, 'X-Custom': 'value' }));
  context.setBody({ ...body, timestamp: Date.now() });
}
```

## Explanation

1. Each hook is set when setting up your instance
2. Each hook's value is a callback which has a context in it's argument.
3. The context has the request, result and config of the instance at runtime.
4. You can modify using **helper methods** or by returning the modified context.
5. Helper methods provide a clean, intuitive way to make common modifications.
6. You can still use the traditional return approach for complex scenarios.

### The context object has the following properties:

A) request: The request object that is being sent.

This includes `url`, `method` and `options` for that request.

B) result: The result object that is being received.

This is Z-fetch result including `data`, `error`, `response` and other properties.

C) config: The configuration object that is being used.

D) Helper methods: `setHeaders()`, `setBody()`, `setOptions()`, `setUrl()`, `setMethod()`, `setError()`

-> Tip: you can always just pick only what you want to modify, and then return that after modifying it.

## Available Hooks

### onRequest Hook

Request hooks allow you to modify the request before it's sent:

```js
const api = createInstance({
  baseUrl: 'https://jsonplaceholder.typicode.com',
  hooks: {
    onRequest: async (context) => {
      console.log('Request about to be sent:', context.request);

      // Using helper methods (recommended)
      if (context.request.method === 'GET') {
        context.setUrl(context.request.url + '?custom=true');
      }

      // Add timestamp header easily
      context.setHeaders(headers => ({
        ...headers,
        'X-Timestamp': Date.now().toString()
      }));

      // Or traditional return approach
      return {
        request: {
          ...context.request,
          options: {
            ...context.request.options,
            headers: {
              ...context.request.options.headers,
              'X-Traditional': 'value'
            }
          }
        }
      };
    }
  }
});
```

### onResponse Hook

Response hooks allow you to modify the response before it's returned:

```js
const api = createInstance({
  baseUrl: 'https://jsonplaceholder.typicode.com',
  hooks: {
    onResponse: async ({ result }) => {
      console.log('Response received:', result);

      // Transform the response data
      if (result?.data) {
        return {
          result: {
            ...result,
            data: {
              ...result.data,
              processed: true,
              timestamp: Date.now()
            }
          }
        };
      }

      return { result };
    }
  }
});
```

### ðŸ†• onError Hook

The new **onError hook** intercepts all error types and allows you to modify error messages and status codes:

```js
const api = createInstance({
  baseUrl: 'https://api.example.com',
  hooks: {
    onError: (context) => {
      console.log('Error occurred:', context.error);
      
      // Using helper method (recommended)
      context.setError({
        message: 'User-friendly error message',
        status: context.error?.status || 'UNKNOWN'
      });
      
      // Or traditional return approach
      return {
        error: { 
          message: 'Custom message', 
          status: 'CUSTOM_ERROR' 
        }
      };
    }
  }
});
```

**onError Hook Features:**
- **Complete coverage**: HTTP errors, network failures, timeouts, parse errors
- **Error modification**: Change error messages and status codes using `setError()`
- **Context access**: Full request details, configuration, and error information
- **Integration**: Works with error mapping and alongside other hooks

### Combining All Hooks

You can use all three hooks together for comprehensive request/response processing:

```js
const api = createInstance({
  baseUrl: 'https://api.example.com',
  hooks: {
    onRequest: async (context) => {
      // Add authentication using helper method
      const token = localStorage.getItem('auth_token');
      if (token) {
        context.setHeaders(headers => ({
          ...headers,
          'Authorization': `Bearer ${token}`
        }));
      }
      
      // Add timestamp to request body
      if (context.request.options.body && typeof context.request.options.body === 'object') {
        context.setBody({
          ...context.request.options.body,
          timestamp: Date.now()
        });
      }
    },
    
    onResponse: async ({ result }) => {
      // Process successful responses
      if (result?.data && !result.error) {
        return {
          result: {
            ...result,
            data: {
              ...result.data,
              processedAt: new Date().toISOString()
            }
          }
        };
      }
      return { result };
    },
    
    onError: (context) => {
      // Handle different error types
      if (context.error?.status === 401) {
        localStorage.removeItem('auth_token');
        context.setError({
          message: 'Session expired. Please login again.',
          status: 'AUTHENTICATION_FAILED'
        });
      } else if (context.error?.status === 'NETWORK_ERROR') {
        context.setError({
          message: 'Connection failed. Please check your internet.',
          status: 'CONNECTION_ERROR'
        });
      }
    }
  }
});
```

### Real-World Example: Complete Request Lifecycle

```js
const api = createInstance({
  baseUrl: 'https://api.example.com',
  hooks: {
    onRequest: async (context) => {
      // Log all outgoing requests
      console.log(`[${new Date().toISOString()}] Sending ${context.request.method} request to ${context.request.url}`);

      // Add authentication token from localStorage
      const token = localStorage.getItem('auth_token');
      if (token) {
        context.setHeaders(headers => ({
          ...headers,
          'Authorization': `Bearer ${token}`
        }));
      }

      // Add request ID for tracking
      context.setHeaders(headers => ({
        ...headers,
        'X-Request-ID': crypto.randomUUID()
      }));
    },
    
    onResponse: async ({ result, config }) => {
      // Add metadata to successful responses
      if (result?.data) {
        return {
          result: {
            ...result,
            data: {
              ...result.data,
              _meta: {
                timestamp: Date.now(),
                environment: process.env.NODE_ENV
              }
            }
          }
        };
      }
      return { result };
    },
    
    onError: (context) => {
      // Handle authentication errors
      if (context.error?.status === 401) {
        localStorage.removeItem('auth_token');
        window.location.href = '/login';
        context.setError({
          message: 'Authentication failed. Redirecting to login...',
          status: 'AUTH_REQUIRED'
        });
      }
      
      // Handle server errors
      if (context.error?.status >= 500) {
        context.setError({
          message: 'Server error. Please try again later.',
          status: 'SERVER_ERROR'
        });
      }
      
      // Handle network errors
      if (context.error?.status === 'NETWORK_ERROR') {
        context.setError({
          message: 'Network connection failed. Please check your internet connection.',
          status: 'CONNECTION_FAILED'
        });
      }
    }
  }
});
```

## Migration Guide

If you're using the old spreading patterns, you can easily migrate to the new helper methods:

**Old approach:**
```js
onRequest: async (context) => {
  return {
    request: {
      ...context.request,
      options: {
        ...context.request.options,
        headers: { ...context.request.options.headers, 'X-Auth': token }
      }
    }
  };
}
```

**New approach:**
```js
onRequest: async (context) => {
  context.setHeaders(headers => ({ ...headers, 'X-Auth': token }));
}
```

The new helper methods are cleaner, less error-prone, and more intuitive while maintaining full backwards compatibility.

With these powerful hooks and helper methods, you can implement complex request/response processing, authentication flows, logging, error handling, and data transformation in a clean and reusable way.
