---
title: Hook Basics
description: Understanding the fundamentals of Z-Fetch hooks and lifecycle management.
---

Hooks are a powerful feature that allow you to intercept and modify requests and responses throughout the request lifecycle. They're perfect for implementing authentication, logging, caching, error handling, and more.

<Callout title="Looking for interceptors?" type="warn">
  You want to hook into some lifecycle? Great, they're called hooks!
</Callout>

## What Are Hooks?

Hooks let you "hook into" different phases of the request lifecycle:

- **`onRequest`** - Modify requests before they're sent
- **`onResponse`** - Process responses before they're returned
- **`onError`** - Handle and modify errors (enhanced with comprehensive error handling)

This is a common pattern in fetch libraries that provides powerful customization capabilities. The enhanced hooks system now includes improved error handling with the `onError` hook for comprehensive error management.

## Hook Lifecycle

```
Request Started
      â†“
  onRequest Hook  â† Modify URL, headers, body, options
      â†“
  Make Request
      â†“
  Response/Error
      â†“
onResponse/onError  â† Process response or handle errors
      â†“
  Return Result
```

## Basic Hook Setup

### With Instance

```js
import { createInstance } from "@z-fetch/fetch";

const api = createInstance({
  baseUrl: "https://api.example.com",
  hooks: {
    onRequest: async (context) => {
      console.log("Making request to:", context.request.url);
      // Modify request here
    },
    onResponse: async (context) => {
      console.log("Received response:", context.response.status);
      // Process response here
    },
    onError: async (context) => {
      console.log("Request failed:", context.error.message);
      // Handle error here
    },
  },
});
```

### With Individual Requests

```js
import { GET } from "@z-fetch/fetch";

const { data, error } = await GET("https://api.example.com/data", {
  hooks: {
    onRequest: async (context) => {
      console.log("Request starting...");
    },
    onResponse: async (context) => {
      console.log("Response received!");
    },
  },
});
```

## Hook Context

Each hook receives a context object with different properties:

### onRequest Context

```js
{
  request: {
    url: string,
    method: string,
    options: RequestOptions
  },
  config: InstanceConfig,
  // Helper methods (see next sections)
  setUrl: (url) => void,
  setMethod: (method) => void,
  setHeaders: (updater) => void,
  setBody: (body) => void,
  setOptions: (updater) => void
}
```

### onResponse Context

```js
{
  request: RequestInfo,
  response: Response,
  data: any,
  config: InstanceConfig,
  // Processing helpers available here too
}
```

### onError Context

```js
{
  request: RequestInfo,
  error: Error,
  config: InstanceConfig,
  // Error modification helpers
  setError: (error) => void
}
```

## Simple Examples

### Request Logging

```js
const api = createInstance({
  hooks: {
    onRequest: async (context) => {
      const { url, method } = context.request;
      console.log(`â†’ ${method} ${url}`);
      console.log("Request started at:", new Date().toISOString());
    },
    onResponse: async (context) => {
      const { status, statusText } = context.response;
      console.log(`â† ${status} ${statusText}`);
      console.log("Request completed at:", new Date().toISOString());
    },
  },
});
```

### Basic Authentication

```js
const api = createInstance({
  hooks: {
    onRequest: async (context) => {
      const token = localStorage.getItem("authToken");
      if (token) {
        context.setHeaders((headers) => ({
          ...headers,
          Authorization: `Bearer ${token}`,
        }));
      }
    },
  },
});
```

### Response Validation

```js
const api = createInstance({
  hooks: {
    onResponse: async (context) => {
      if (context.response.status === 401) {
        console.log("Authentication expired, redirecting to login...");
        window.location.href = "/login";
      }
    },
  },
});
```

## Multiple Hooks

You can combine multiple hooks for complex workflows:

```js
const api = createInstance({
  hooks: {
    onRequest: async (context) => {
      // Add authentication
      const token = getAuthToken();
      if (token) {
        context.setHeaders((headers) => ({
          ...headers,
          Authorization: `Bearer ${token}`,
        }));
      }

      // Add request ID for tracking
      context.setHeaders((headers) => ({
        ...headers,
        "X-Request-ID": generateRequestId(),
      }));

      // Log request
      console.log(`Starting ${context.request.method} ${context.request.url}`);
    },

    onResponse: async (context) => {
      // Log response
      console.log(`Completed with status ${context.response.status}`);

      // Cache successful responses
      if (context.response.ok && context.request.method === "GET") {
        cacheResponse(context.request.url, context.data);
      }
    },

    onError: async (context) => {
      // Log errors
      console.error("Request failed:", context.error.message);

      // Track errors
      trackError({
        url: context.request.url,
        method: context.request.method,
        error: context.error.message,
      });
    },
  },
});
```

## Hook Execution Order

1. **Instance hooks** run first
2. **Request-level hooks** run second
3. Hooks of the same type run in the order they're defined

```js
const api = createInstance({
  hooks: {
    onRequest: async (context) => {
      console.log("1. Instance onRequest");
    },
  },
});

// This request will run both hooks
await api.get("/data", {
  hooks: {
    onRequest: async (context) => {
      console.log("2. Request onRequest");
    },
  },
});

// Output:
// 1. Instance onRequest
// 2. Request onRequest
```

## Return Values vs Helper Methods

You can modify context in two ways:

### Using Helper Methods (Recommended)

```js
onRequest: async (context) => {
  context.setHeaders((headers) => ({ ...headers, "X-Custom": "value" }));
  context.setBody({ ...context.request.options.body, timestamp: Date.now() });
};
```

### Using Return Values

```js
onRequest: async (context) => {
  return {
    request: {
      ...context.request,
      options: {
        ...context.request.options,
        headers: {
          ...context.request.options.headers,
          "X-Custom": "value",
        },
      },
    },
  };
};
```

<Callout title="Best Practice" type="info">
  Helper methods are recommended as they're more readable and less error-prone
  than manual spreading.
</Callout>

## Related Features

Hooks work seamlessly with other Z-Fetch features:

- **[ðŸŒŠ Streaming Support](/docs/features/streaming)** - Process response streams with built-in utilities
- **[ðŸ“Š Progress Tracking](/docs/features/progress-tracking)** - Real-time upload and download progress monitoring
- **[ðŸš¨ Error Handling](/docs/features/error-handling)** - Comprehensive error handling with onError hook and error mapping
- **[ðŸ’ª Using Hooks](/docs/using-hooks)** - Advanced hooks usage patterns and examples

## Common Patterns

### Conditional Logic

```js
onRequest: async (context) => {
  // Only add auth to API requests
  if (context.request.url.includes("/api/")) {
    const token = getAuthToken();
    if (token) {
      context.setHeaders((headers) => ({
        ...headers,
        Authorization: `Bearer ${token}`,
      }));
    }
  }
};
```

### Environment-Based Configuration

```js
const api = createInstance({
  hooks: {
    onRequest: async (context) => {
      if (process.env.NODE_ENV === "development") {
        console.log("DEV REQUEST:", context.request);
      }

      // Add API key for production
      if (process.env.NODE_ENV === "production") {
        context.setHeaders((headers) => ({
          ...headers,
          "X-API-Key": process.env.API_KEY,
        }));
      }
    },
  },
});
```
