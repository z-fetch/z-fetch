{"version":3,"sources":["../src/lib/index.ts"],"names":["url","method","patch"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Supported HTTP methods for z-fetch requests.\n * Includes standard HTTP methods and support for custom methods.\n */\nexport type METHODS =\n  | \"GET\"\n  | \"POST\"\n  | \"PUT\"\n  | \"DELETE\"\n  | \"PATCH\"\n  | \"OPTIONS\"\n  | \"TRACE\"\n  | \"HEAD\"\n  | \"CUSTOM\"\n  | string;\n\n/**\n * Utility type for making all properties of an object optional recursively.\n * Used internally for partial context updates in hooks.\n */\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n/**\n * Hook function type for intercepting and modifying requests/responses.\n * Hooks can be synchronous or asynchronous and can return partial context updates.\n *\n * @param context - The current request/response context\n * @returns A partial context update object or void\n *\n * @example\n * ```typescript\n * const requestHook: Hook = async (context) => {\n *   // Add custom header\n *   context.setHeaders(headers => ({ ...headers, 'X-Custom': 'value' }));\n *\n *   // Or return a partial update\n *   return {\n *     request: {\n *       options: {\n *         headers: { ...context.request.options.headers, 'X-Custom': 'value' }\n *       }\n *     }\n *   };\n * };\n * ```\n */\nexport type Hook = (\n  context: Context,\n) => Promise<DeepPartial<Context> | void> | DeepPartial<Context> | void;\n\n/**\n * Context object passed to hooks containing request/response information and helper methods.\n * Provides access to configuration, request details, response data, and utility functions.\n *\n * @example\n * ```typescript\n * const onRequest: Hook = (context) => {\n *   // Access current request\n *   console.log(context.request.method, context.request.url);\n *\n *   // Use helper methods\n *   context.setHeaders(headers => ({ ...headers, 'Authorization': 'Bearer token' }));\n *   context.setBody({ timestamp: Date.now() });\n * };\n * ```\n */\nexport type Context = {\n  /** Current z-fetch configuration */\n  config: Config;\n  /** Request information including method, URL, and options */\n  request: {\n    method: METHODS;\n    url: string;\n    options: RequestOptions;\n  };\n  /** Response result (null during onRequest hook) */\n  result: RequestResult | null;\n  /** Error information (null if no error occurred) */\n  error: { message: string; status: string | number } | null;\n\n  // Helper methods for easier manipulation\n  /** Helper method to update request headers */\n  setHeaders: (\n    updater: (headers: {\n      [key: string]: string;\n    }) => { [key: string]: string } | void,\n  ) => void;\n  /** Helper method to update request body */\n  setBody: (body: any) => void;\n  /** Helper method to update request options */\n  setOptions: (\n    updater: (options: RequestOptions) => RequestOptions | void,\n  ) => void;\n  /** Helper method to update request URL */\n  setUrl: (url: string) => void;\n  /** Helper method to update request method */\n  setMethod: (method: METHODS) => void;\n  /** Helper method to update error information */\n  setError: (\n    error: { message: string; status: string | number } | null,\n  ) => void;\n};\n\n/**\n * Configuration object for z-fetch instances and requests.\n * Defines default behaviors, authentication, hooks, and other options.\n *\n * @example\n * ```typescript\n * const config: Config = {\n *   baseUrl: 'https://api.example.com',\n *   bearerToken: 'your-token',\n *   headers: { 'Content-Type': 'application/json' },\n *   throwOnError: true, // Throw errors instead of returning them\n *   hooks: {\n *     onRequest: (context) => {\n *       context.setHeaders(headers => ({ ...headers, 'X-Timestamp': Date.now().toString() }));\n *     },\n *     onError: (context) => {\n *       console.error('Request failed:', context.error);\n *     }\n *   },\n *   onUploadProgress: (event) => {\n *     console.log(`Upload: ${event.loaded}/${event.total}`);\n *   }\n * };\n * ```\n */\nexport type Config = {\n  /** Base URL to prepend to all request URLs */\n  baseUrl: string;\n  /** Bearer token for automatic Authorization header */\n  bearerToken: string | null;\n  /** Request timeout in milliseconds */\n  timeout: number;\n  /** Whether to enable automatic retries on failure */\n  retry: boolean;\n  /** Maximum number of retry attempts */\n  maxRetries: number;\n  /** Whether to start polling immediately after request */\n  startPolling: boolean;\n  /** Whether to stop any active polling */\n  stopPolling: boolean;\n  /** Interval between polling requests in milliseconds */\n  pollingInterval: number;\n  /** Cache revalidation interval in milliseconds */\n  revalidateCache: number;\n  /** Whether to include credentials in requests */\n  withCredentials: boolean;\n  /** Whether to enable response caching for GET requests */\n  withCache: boolean;\n  /** Whether to automatically parse JSON responses */\n  parseJson: boolean;\n  /** Whether to automatically stringify request payload */\n  stringifyPayload: boolean;\n  /** CORS mode for the request */\n  mode: RequestMode;\n  /** Default headers to include with all requests */\n  headers: { [key: string]: string };\n  /** Hook functions for request/response/error interception */\n  hooks: {\n    /** Called before sending the request */\n    onRequest?: Hook;\n    /** Called after receiving the response */\n    onResponse?: Hook;\n    /** Called when an error occurs */\n    onError?: Hook;\n  };\n  /** Mapping of status codes/patterns to custom error messages */\n  errorMapping?: {\n    [statusCode: number]: string;\n    [statusPattern: string]: string;\n  };\n  /** Whether to throw errors instead of returning them in result.error */\n  throwOnError: boolean;\n  /** Callback for upload progress tracking */\n  onUploadProgress?: (event: ProgressEvent) => void;\n  /** Callback for download progress tracking */\n  onDownloadProgress?: (event: ProgressEvent) => void;\n  /** Force XMLHttpRequest when progress callbacks are provided */\n  useXHRForProgress?: boolean;\n};\n\n/**\n * Result object returned by z-fetch requests containing response data and utility methods.\n * Provides access to response data, error information, and various control methods.\n *\n * @example\n * ```typescript\n * const result = await api.get('/users');\n *\n * if (result.error) {\n *   console.error('Request failed:', result.error.message);\n * } else {\n *   console.log('Users:', result.data);\n *\n *   // Stream response data\n *   const text = await result.streamToString();\n *\n *   // Start polling for updates\n *   result.onPollDataReceived((newResult) => {\n *     console.log('Updated data:', newResult.data);\n *   });\n *   result.startPolling(5000);\n * }\n * ```\n */\nexport type RequestResult = {\n  /** Whether the request is currently loading */\n  loading: boolean;\n  /** Error information if the request failed */\n  error: { message: string; status: string | number } | null;\n  /** Response data (parsed JSON or raw text based on parseJson config) */\n  data: any;\n  /** Raw Response object from fetch API */\n  response: Response | null;\n  /** Method to refetch the same request */\n  refetch: (callback: (result: RequestResult) => void) => Promise<any>;\n  /** Method to cancel the ongoing request */\n  cancelRequest: () => void;\n  /** Method to start polling for updates */\n  startPolling: (interval?: number) => void;\n  /** Method to stop active polling */\n  stopPolling: () => void;\n  /** Method to set callback for polling data updates */\n  onPollDataReceived: (callback: (result: RequestResult) => void) => void;\n\n  // Streaming utilities\n  /** Stream response body as string */\n  streamToString?: () => Promise<string>;\n  /** Stream response body as Blob */\n  streamToBlob?: () => Promise<Blob>;\n  /** Stream response body as ArrayBuffer */\n  streamToArrayBuffer?: () => Promise<ArrayBuffer>;\n  /** Stream response body chunk by chunk */\n  streamChunks?: (callback: (chunk: Uint8Array) => void) => Promise<void>;\n};\n\n/** Cancelable promise type for early cancellation */\nexport type CancelablePromise<T> = Promise<T> & { cancel: () => void };\n\n/**\n * Request options for z-fetch requests.\n * Extends standard RequestInit while allowing object bodies and partial Config options.\n *\n * @example\n * ```typescript\n * const options: RequestOptions = {\n *   body: { name: 'John', age: 30 }, // Will be JSON.stringify'd if stringifyPayload is true\n *   headers: { 'X-Custom': 'value' },\n *   timeout: 10000,\n *   bearerToken: 'override-token',\n *   onUploadProgress: (event) => console.log(`Progress: ${event.loaded}/${event.total}`)\n * };\n *\n * const result = await api.post('/users', options);\n * ```\n */\nexport type RequestOptions = Omit<RequestInit, \"body\"> & {\n  /** Request body - can be object (will be stringified), string, or any BodyInit */\n  body?: BodyInit | object | null;\n} & Partial<Config>;\n\n/**\n * Default configuration object for z-fetch.\n * Provides sensible defaults for all configuration options.\n * Can be overridden globally or per-instance.\n *\n * @example\n * ```typescript\n * // Global config override\n * Object.assign(defaultConfig, {\n *   baseUrl: 'https://api.myapp.com',\n *   timeout: 60000\n * });\n *\n * // Or use createInstance for per-instance config\n * const api = createInstance({\n *   ...defaultConfig,\n *   bearerToken: 'my-token'\n * });\n * ```\n */\nexport const defaultConfig: Config = {\n  baseUrl: \"\",\n  bearerToken: null,\n  timeout: 90000,\n  retry: false,\n  maxRetries: 3,\n  startPolling: false,\n  stopPolling: false,\n  pollingInterval: 5000,\n  revalidateCache: 10000,\n  withCredentials: false,\n  withCache: true,\n  parseJson: true,\n  stringifyPayload: true,\n  mode: \"cors\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Accept: \"*/*\",\n  },\n  hooks: {},\n  errorMapping: {},\n  throwOnError: false,\n  useXHRForProgress: false,\n};\n\nlet config: Config = { ...defaultConfig };\n\n/**\n * Internal cache for storing GET request results.\n * Used when withCache is enabled to avoid duplicate requests.\n */\nconst cache: Map<string, RequestResult> = new Map();\n\n/**\n * Performs HTTP request using XMLHttpRequest for progress tracking support.\n * Used internally when upload/download progress callbacks are provided.\n *\n * @param url - The request URL\n * @param method - HTTP method to use\n * @param options - Request options and configuration\n * @param context - Additional context for error handling\n * @returns Promise resolving to basic request result\n *\n * @internal\n */\nasync function requestWithProgress(\n  url: string,\n  method: METHODS,\n  options: RequestOptions = { ...defaultConfig },\n  context?: { config: Config; onError?: Hook },\n  signal?: AbortSignal,\n): Promise<{\n  loading: boolean;\n  error: { message: string; status: string | number } | null;\n  data: any;\n  response: Response | null;\n}> {\n  return new Promise((resolve, reject) => {\n    const mergedConfig = { ...config, ...options };\n    let fullUrl = mergedConfig.baseUrl ? mergedConfig.baseUrl + url : url;\n\n    const xhr = new XMLHttpRequest();\n\n    // Handle cancellation\n    if (signal) {\n      signal.addEventListener(\"abort\", () => {\n        xhr.abort();\n      });\n    }\n\n    // Setup upload progress tracking\n    if (mergedConfig.onUploadProgress && xhr.upload) {\n      xhr.upload.addEventListener(\"progress\", mergedConfig.onUploadProgress);\n    }\n\n    // Setup download progress tracking\n    if (mergedConfig.onDownloadProgress) {\n      xhr.addEventListener(\"progress\", mergedConfig.onDownloadProgress);\n    }\n\n    const handleError = async (error: {\n      message: string;\n      status: string | number;\n    }) => {\n      if (context?.onError && context.config) {\n        const errorContext = {\n          config: context.config,\n          request: {\n            method,\n            url,\n            options: mergedConfig,\n          },\n          result: null,\n          error,\n          setHeaders: () => {},\n          setBody: () => {},\n          setOptions: () => {},\n          setUrl: () => {},\n          setMethod: () => {},\n          setError: (\n            newError: { message: string; status: string | number } | null,\n          ) => {\n            error = newError || error;\n          },\n        };\n\n        const patch = await context.onError(errorContext);\n        if (patch?.error !== undefined) {\n          error = patch.error || error;\n        }\n      }\n      return error;\n    };\n\n    xhr.addEventListener(\"loadend\", async () => {\n      let error: { message: string; status: string | number } | null = null;\n      let data: any = null;\n      let response: Response | null = null;\n\n      if (xhr.status >= 200 && xhr.status < 300) {\n        try {\n          data = mergedConfig.parseJson\n            ? JSON.parse(xhr.responseText)\n            : xhr.responseText;\n          // Create a mock Response object for compatibility\n          response = {\n            ok: true,\n            status: xhr.status,\n            statusText: xhr.statusText,\n            url: fullUrl,\n            headers: new Headers(),\n            json: async () =>\n              mergedConfig.parseJson\n                ? JSON.parse(xhr.responseText)\n                : xhr.responseText,\n            text: async () => xhr.responseText,\n            blob: async () => new Blob([xhr.response]),\n            arrayBuffer: async () => xhr.response as any,\n            formData: async () => new FormData(),\n            body: null,\n            bodyUsed: false,\n            clone: function () {\n              return this;\n            },\n            type: \"basic\",\n            redirected: false,\n          } as Response;\n        } catch {\n          error = {\n            message: \"Failed to parse response\",\n            status: \"PARSE_ERROR\",\n          };\n          error = await handleError(error);\n        }\n      } else {\n        const originalMessage = xhr.statusText;\n        let mappedMessage = originalMessage;\n\n        // Apply error mapping if configured\n        if (mergedConfig.errorMapping) {\n          // Check for exact status code match\n          if (mergedConfig.errorMapping[xhr.status]) {\n            mappedMessage = mergedConfig.errorMapping[xhr.status];\n          } else {\n            // Check for pattern matches\n            for (const [pattern, message] of Object.entries(\n              mergedConfig.errorMapping,\n            )) {\n              if (typeof pattern === \"string\") {\n                if (pattern === xhr.status.toString()) {\n                  mappedMessage = message;\n                  break;\n                }\n                if (\n                  originalMessage\n                    .toLowerCase()\n                    .includes(pattern.toLowerCase()) ||\n                  xhr.status.toString().includes(pattern)\n                ) {\n                  mappedMessage = message;\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        error = { message: mappedMessage, status: xhr.status };\n        error = await handleError(error);\n      }\n\n      if (mergedConfig.throwOnError && error) {\n        reject(error);\n      } else {\n        resolve({ loading: false, error, data, response });\n      }\n    });\n\n    xhr.addEventListener(\"error\", async () => {\n      let mappedMessage = \"Network error\";\n\n      // Apply error mapping for network errors if configured\n      if (mergedConfig.errorMapping) {\n        for (const [pattern, message] of Object.entries(\n          mergedConfig.errorMapping,\n        )) {\n          if (typeof pattern === \"string\") {\n            if (\n              pattern.toLowerCase() === \"network_error\" ||\n              pattern.toLowerCase() === \"fetch failed\"\n            ) {\n              mappedMessage = message;\n              break;\n            }\n          }\n        }\n      }\n\n      let error: { message: string; status: string | number } = {\n        message: mappedMessage,\n        status: \"NETWORK_ERROR\",\n      };\n      const handledError = await handleError(error);\n      error = handledError || error;\n\n      if (mergedConfig.throwOnError) {\n        reject(error);\n      } else {\n        resolve({\n          loading: false,\n          error,\n          data: null,\n          response: null,\n        });\n      }\n    });\n\n    xhr.addEventListener(\"timeout\", async () => {\n      let error: { message: string; status: string | number } = {\n        message: \"Request timed out!\",\n        status: \"TIMEOUT\",\n      };\n      const handledError = await handleError(error);\n      error = handledError || error;\n\n      if (mergedConfig.throwOnError) {\n        reject(error);\n      } else {\n        resolve({\n          loading: false,\n          error,\n          data: null,\n          response: null,\n        });\n      }\n    });\n\n    xhr.addEventListener(\"abort\", async () => {\n      let error: { message: string; status: string | number } = {\n        message: \"Request canceled\",\n        status: \"CANCELED\",\n      };\n      const handledError = await handleError(error);\n      error = handledError || error;\n\n      if (mergedConfig.throwOnError) {\n        reject(error);\n      } else {\n        resolve({\n          loading: false,\n          error,\n          data: null,\n          response: null,\n        });\n      }\n    });\n\n    // Setup the request\n    xhr.open(method, fullUrl);\n    xhr.timeout = mergedConfig.timeout;\n\n    // Set headers\n    const headers = { ...config.headers, ...(options.headers || {}) };\n    if (mergedConfig.bearerToken && !headers[\"Authorization\"]) {\n      headers[\"Authorization\"] = `Bearer ${mergedConfig.bearerToken}`;\n    }\n\n    Object.entries(headers).forEach(([key, value]) => {\n      xhr.setRequestHeader(key, String(value));\n    });\n\n    // Set credentials\n    if (mergedConfig.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    // Send the request\n    let body: any = null;\n    if (mergedConfig.body !== undefined) {\n      if (typeof mergedConfig.body === \"object\" && mergedConfig.body !== null) {\n        body = mergedConfig.stringifyPayload\n          ? JSON.stringify(mergedConfig.body)\n          : mergedConfig.body;\n      } else {\n        body = mergedConfig.body;\n      }\n    }\n\n    xhr.send(body);\n  });\n}\n\n/**\n * Core request function that handles HTTP requests using fetch API or XMLHttpRequest.\n * Provides comprehensive error handling, retries, caching, polling, and streaming support.\n * Automatically switches to XMLHttpRequest when progress tracking is needed.\n *\n * @param url - The request URL (can be relative if baseUrl is configured)\n * @param method - HTTP method to use\n * @param options - Request options and configuration overrides\n * @returns Promise resolving to RequestResult with response data and utilities\n *\n * @internal\n */\nfunction request(\n  url: string,\n  method: METHODS,\n  options: RequestOptions = { ...defaultConfig },\n): CancelablePromise<RequestResult> {\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  // Merge configuration properly\n  const mergedConfig = { ...config, ...options };\n  let fullUrl = mergedConfig.baseUrl ? mergedConfig.baseUrl + url : url;\n\n  // Check if we should use XMLHttpRequest for progress tracking\n  const shouldUseXHR =\n    mergedConfig.useXHRForProgress ||\n    mergedConfig.onUploadProgress ||\n    mergedConfig.onDownloadProgress;\n\n  let pollingIntervalId: any | null = null;\n  let pollCallback: ((result: RequestResult) => void) | null = null;\n\n  const cancelRequest = (): void => {\n    abortController.abort();\n  };\n\n  const promise = new Promise<RequestResult>(async (resolve, reject) => {\n    let loading = true;\n    let error: { message: string; status: string | number } | null = null;\n    let data: any = null;\n    let retryCount = 0;\n    let timedOut = false;\n\n    const handleError = async (errObj: {\n      message: string;\n      status: string | number;\n    }) => {\n      if (mergedConfig.hooks?.onError) {\n        const errorContext = {\n          config: mergedConfig,\n          request: {\n            method,\n            url,\n            options: mergedConfig,\n          },\n          result: null,\n          error: errObj,\n          setHeaders: () => {},\n          setBody: () => {},\n          setOptions: () => {},\n          setUrl: () => {},\n          setMethod: () => {},\n          setError: (\n            newError: { message: string; status: string | number } | null,\n          ) => {\n            errObj = newError || errObj;\n          },\n        };\n        const patch = await mergedConfig.hooks.onError(errorContext);\n        if (patch?.error !== undefined) {\n          errObj = patch.error || errObj;\n        }\n      }\n      return errObj;\n    };\n\n    const performRequest = async (): Promise<{\n      loading: boolean;\n      error: typeof error;\n      data: any;\n      response: Response | null;\n    }> => {\n      // Use XMLHttpRequest if progress tracking is needed\n      if (shouldUseXHR) {\n        return await requestWithProgress(\n          url,\n          method,\n          options,\n          {\n            config: mergedConfig,\n            onError: mergedConfig.hooks?.onError,\n          },\n          signal,\n        );\n      }\n\n      try {\n        // Handle bearerToken option - but don't override explicit Authorization header\n        const headers = { ...config.headers, ...(options.headers || {}) };\n        if (mergedConfig.bearerToken && !headers[\"Authorization\"]) {\n          headers[\"Authorization\"] = `Bearer ${mergedConfig.bearerToken}`;\n        }\n\n        // Only pass valid fetch options, excluding z-fetch specific config\n        let fetchOptions: RequestInit = {\n          signal,\n          method,\n          headers,\n        };\n\n        // Add valid fetch options from merged config\n        if (mergedConfig.body !== undefined) {\n          if (\n            typeof mergedConfig.body === \"object\" &&\n            mergedConfig.body !== null\n          ) {\n            fetchOptions.body = mergedConfig.stringifyPayload\n              ? JSON.stringify(mergedConfig.body)\n              : (mergedConfig.body as BodyInit);\n          } else {\n            fetchOptions.body = mergedConfig.body as BodyInit;\n          }\n        }\n        if (mergedConfig.cache !== undefined)\n          fetchOptions.cache = mergedConfig.cache;\n        if (mergedConfig.credentials !== undefined)\n          fetchOptions.credentials = mergedConfig.credentials;\n        if (mergedConfig.withCredentials) fetchOptions.credentials = \"include\";\n        if (mergedConfig.integrity !== undefined)\n          fetchOptions.integrity = mergedConfig.integrity;\n        if (mergedConfig.keepalive !== undefined)\n          fetchOptions.keepalive = mergedConfig.keepalive;\n        if (mergedConfig.mode !== undefined)\n          fetchOptions.mode = mergedConfig.mode;\n        if (mergedConfig.redirect !== undefined)\n          fetchOptions.redirect = mergedConfig.redirect;\n        if (mergedConfig.referrer !== undefined)\n          fetchOptions.referrer = mergedConfig.referrer;\n        if (mergedConfig.referrerPolicy !== undefined)\n          fetchOptions.referrerPolicy = mergedConfig.referrerPolicy;\n\n        if (options.baseUrl) {\n          fullUrl = options.baseUrl + url;\n        }\n\n        const timeoutId = setTimeout(() => {\n          timedOut = true;\n          abortController.abort();\n        }, mergedConfig.timeout);\n\n        const response = await fetch(fullUrl, fetchOptions);\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          const originalMessage = response.statusText;\n          let mappedMessage = originalMessage;\n\n          // Apply error mapping if configured\n          if (mergedConfig.errorMapping) {\n            // Check for exact status code match\n            if (mergedConfig.errorMapping[response.status]) {\n              mappedMessage = mergedConfig.errorMapping[response.status];\n            } else {\n              // Check for pattern matches\n              for (const [pattern, message] of Object.entries(\n                mergedConfig.errorMapping,\n              )) {\n                if (typeof pattern === \"string\") {\n                  // Check if status code matches pattern\n                  if (pattern === response.status.toString()) {\n                    mappedMessage = message;\n                    break;\n                  }\n                  // Check if original message contains pattern (case insensitive)\n                  if (\n                    originalMessage\n                      .toLowerCase()\n                      .includes(pattern.toLowerCase()) ||\n                    response.status.toString().includes(pattern)\n                  ) {\n                    mappedMessage = message;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          error = { message: mappedMessage, status: response.status };\n          error = await handleError(error);\n        } else {\n          // Clone response for data extraction to preserve body for streaming utilities\n          const responseForData = response.clone();\n          data = mergedConfig.parseJson\n            ? await responseForData.json()\n            : await responseForData.text();\n        }\n\n        loading = false;\n        return { loading, error, data, response };\n      } catch (err: any) {\n        let status: string | number = \"NETWORK_ERROR\";\n        let message: string = err?.message || \"Network error\";\n\n        if (signal.aborted) {\n          if (timedOut) {\n            message = \"Request timed out!\";\n            status = \"TIMEOUT\";\n          } else {\n            message = \"Request canceled\";\n            status = \"CANCELED\";\n          }\n        }\n\n        // Apply error mapping for network errors if configured (skip for cancel/timeout)\n        if (\n          status === \"NETWORK_ERROR\" &&\n          mergedConfig.errorMapping &&\n          typeof message === \"string\"\n        ) {\n          for (const [pattern, mapped] of Object.entries(\n            mergedConfig.errorMapping,\n          )) {\n            if (typeof pattern === \"string\") {\n              if (\n                message.toLowerCase().includes(pattern.toLowerCase()) ||\n                pattern.toLowerCase() === \"network_error\" ||\n                pattern.toLowerCase() === \"fetch failed\"\n              ) {\n                message = mapped;\n                break;\n              }\n            }\n          }\n        }\n\n        let errObj = { message, status } as {\n          message: string;\n          status: string | number;\n        };\n        errObj = (await handleError(errObj)) || errObj;\n        loading = false;\n        return { loading, error: errObj, data, response: null };\n      }\n    };\n\n    const refetch = async (\n      callback: (result: RequestResult) => void,\n    ): Promise<any> => {\n      const newData = await performRequest();\n      return callback({\n        ...newData,\n        refetch,\n        cancelRequest,\n        startPolling,\n        stopPolling,\n        onPollDataReceived,\n      });\n    };\n\n    const stopPolling = (): void => {\n      if (pollingIntervalId) {\n        clearInterval(pollingIntervalId);\n        pollingIntervalId = null;\n      }\n    };\n\n    const onPollDataReceived = (\n      callback: (result: RequestResult) => void,\n    ): void => {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"onPollDataReceived callback must be a function\");\n      }\n      pollCallback = callback;\n      // Start polling if it was requested but delayed due to missing callback\n      if (mergedConfig.startPolling && !pollingIntervalId) {\n        startPolling();\n      }\n    };\n\n    const startPolling = (\n      interval: number = mergedConfig.pollingInterval,\n    ): void => {\n      if (!pollCallback) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          \"Polling not started: onPollDataReceived callback not set\",\n        );\n        return;\n      }\n      if (pollingIntervalId) {\n        stopPolling(); // Clear existing interval if any\n      }\n      pollingIntervalId = setInterval(async () => {\n        try {\n          const newResult = await performRequest();\n          pollCallback!(newResult as RequestResult);\n          Object.assign(result, newResult);\n        } catch (pollError) {\n          // eslint-disable-next-line no-console\n          console.error(\"Polling error:\", pollError);\n        }\n      }, interval);\n    };\n\n    // Placeholder for result to support streaming utils referencing latest response\n    let result = await performRequest();\n\n    while (\n      mergedConfig.retry &&\n      retryCount < mergedConfig.maxRetries &&\n      result.error\n    ) {\n      retryCount++;\n      result = await performRequest();\n    }\n\n    // Streaming utility functions\n    const streamToString = async (): Promise<string> => {\n      if (!result.response) {\n        throw new Error(\"No response available for streaming\");\n      }\n      if (typeof result.response.text !== \"function\") {\n        throw new Error(\"No response body available for streaming\");\n      }\n      try {\n        return await result.response.text();\n      } catch {\n        throw new Error(\"Failed to read response as text\");\n      }\n    };\n\n    const streamToBlob = async (): Promise<Blob> => {\n      if (!result.response) {\n        throw new Error(\"No response available for streaming\");\n      }\n      if (typeof result.response.blob !== \"function\") {\n        throw new Error(\"No response body available for streaming\");\n      }\n      try {\n        return await result.response.blob();\n      } catch {\n        throw new Error(\"Failed to read response as blob\");\n      }\n    };\n\n    const streamToArrayBuffer = async (): Promise<ArrayBuffer> => {\n      if (!result.response) {\n        throw new Error(\"No response available for streaming\");\n      }\n      if (typeof result.response.arrayBuffer !== \"function\") {\n        throw new Error(\"No response body available for streaming\");\n      }\n      try {\n        return await result.response.arrayBuffer();\n      } catch {\n        throw new Error(\"Failed to read response as array buffer\");\n      }\n    };\n\n    const streamChunks = async (\n      callback: (chunk: Uint8Array) => void,\n    ): Promise<void> => {\n      if (!result.response) {\n        throw new Error(\"No response available for streaming\");\n      }\n      if (!result.response.body) {\n        throw new Error(\"No response body available for streaming\");\n      }\n\n      try {\n        const reader = result.response.body.getReader();\n        try {\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) break;\n            callback(value);\n          }\n        } finally {\n          reader.releaseLock();\n        }\n      } catch {\n        throw new Error(\"Failed to read response stream\");\n      }\n    };\n\n    const cacheKey = `${method}:${fullUrl}`;\n\n    // If we have a cached GET, return it immediately and schedule revalidation\n    if (mergedConfig.withCache && method === \"GET\" && cache.has(cacheKey)) {\n      setTimeout(() => {\n        performRequest().then((newResult) => {\n          if (!newResult.error) {\n            cache.set(cacheKey, {\n              ...newResult,\n              refetch,\n              cancelRequest,\n              startPolling,\n              stopPolling,\n              onPollDataReceived,\n            });\n          }\n        });\n      }, mergedConfig.revalidateCache);\n\n      const cachedResult = cache.get(cacheKey)!;\n      // Throw error if throwOnError is enabled and cached result has an error\n      if (mergedConfig.throwOnError && cachedResult.error) {\n        reject(cachedResult.error);\n        return;\n      }\n      resolve(cachedResult);\n      return;\n    }\n\n    // Cache successful GET requests\n    if (mergedConfig.withCache && method === \"GET\" && !result.error) {\n      cache.set(cacheKey, {\n        ...result,\n        refetch,\n        cancelRequest,\n        startPolling,\n        stopPolling,\n        onPollDataReceived,\n        streamToString,\n        streamToBlob,\n        streamToArrayBuffer,\n        streamChunks,\n      });\n    }\n\n    // Throw error if throwOnError is enabled and there's an error\n    if (mergedConfig.throwOnError && result.error) {\n      reject(result.error);\n      return;\n    }\n\n    resolve({\n      ...result,\n      refetch,\n      cancelRequest,\n      startPolling,\n      stopPolling,\n      onPollDataReceived,\n      streamToString,\n      streamToBlob,\n      streamToArrayBuffer,\n      streamChunks,\n    });\n  }) as CancelablePromise<RequestResult>;\n\n  (promise as CancelablePromise<RequestResult>).cancel = cancelRequest;\n  return promise;\n}\n\n/**\n * Sends an HTTP GET request to the specified URL.\n *\n * @param url - The target URL to send the GET request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await GET('https://api.example.com/resource');\n */\nexport function GET(\n  url: string,\n  options?: RequestOptions,\n): CancelablePromise<RequestResult> {\n  return request(url, \"GET\", options);\n}\n\n/**\n * Sends an HTTP POST request to the specified URL.\n *\n * @param url - The target URL to send the POST request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await POST('https://api.example.com/resource', { body: { key: 'value' } });\n */\nexport function POST(\n  url: string,\n  options?: RequestOptions,\n): CancelablePromise<RequestResult> {\n  return request(url, \"POST\", options);\n}\n\n/**\n * Sends an HTTP PUT request to the specified URL.\n *\n * @param url - The target URL to send the PUT request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await PUT('https://api.example.com/resource', { body: { key: 'value' } });\n */\nexport function PUT(\n  url: string,\n  options?: RequestOptions,\n): CancelablePromise<RequestResult> {\n  return request(url, \"PUT\", options);\n}\n\n/**\n * Sends an HTTP DELETE request to the specified URL.\n *\n * @param url - The target URL to send the DELETE request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await DELETE('https://api.example.com/resource');\n */\nexport function DELETE(\n  url: string,\n  options?: RequestOptions,\n): CancelablePromise<RequestResult> {\n  return request(url, \"DELETE\", options);\n}\n\n/**\n * Sends an HTTP PATCH request to the specified URL.\n *\n * @param url - The target URL to send the PATCH request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n *\n * const result = await PATCH('https://api.example.com/resource', { body: { key: 'value' } });\n *\n */\nexport function PATCH(\n  url: string,\n  options?: RequestOptions,\n): CancelablePromise<RequestResult> {\n  return request(url, \"PATCH\", options);\n}\n\n// Additional HTTP methods\n\n/**\n * Sends an HTTP OPTIONS request to the specified URL.\n *\n * @param url - The target URL to send the OPTIONS request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * ```ts\n * const result = await OPTIONS('https://api.example.com/resource');\n * ```\n */\nexport function OPTIONS(\n  url: string,\n  options?: RequestOptions,\n): CancelablePromise<RequestResult> {\n  return request(url, \"OPTIONS\", options);\n}\n\n/**\n * Sends a TRACE request to the specified URL.\n *\n * The TRACE method performs a message loop-back test along the path to the target resource.\n *\n * @param url - The URL to send the TRACE request to\n * @param options - Optional request configuration options\n * @returns A Promise that resolves to the response from the request\n * @throws {Error} If the request fails or network error occurs\n */\nexport function TRACE(\n  url: string,\n  options?: RequestOptions,\n): CancelablePromise<RequestResult> {\n  return request(url, \"TRACE\", options);\n}\n\n/**\n * Performs an HTTP HEAD request to the specified URL.\n *\n * @param url - The URL to send the HEAD request to\n * @param options - Optional configuration for the request\n * @returns A Promise that resolves with the response data\n *\n * @example\n * ```typescript\n * const result = await HEAD('https://api.example.com/resource');\n * ```\n */\nexport function HEAD(\n  url: string,\n  options?: RequestOptions,\n): CancelablePromise<RequestResult> {\n  return request(url, \"HEAD\", options);\n}\n\n/**\n * CUSTOM method allows you to specify any HTTP method.\n * @param {string} url - The URL to request\n * @param {string} method - The HTTP method (e.g. \"CONNECT\", \"CUSTOM\", etc.)\n * @param {RequestOptions} [options] - Additional options for the request\n * @returns {Promise<RequestResult>} The request result\n */\nexport function CUSTOM(\n  url: string,\n  method: string,\n  options?: RequestOptions,\n): CancelablePromise<RequestResult> {\n  return request(url, method as METHODS, options);\n}\n\n/**\n * Creates a new Z-Fetch instance with custom configuration.\n *\n * @param instanceConfig - Optional configuration object to override default settings\n * @returns An object containing HTTP methods (get, post, etc.) and helper utilities\n *\n * @example\n * ```typescript\n * // Create a new instance with custom config\n * const api = createInstance({\n *   baseUrl: 'https://api.example.com',\n *   headers: { 'Content-Type': 'application/json' },\n *   hooks: {\n *     // Modify request before sending\n *     onRequest: (context) => {\n *       context.request.options.headers['X-Custom-Header'] = 'value';\n *       return context;\n *     },\n *\n *     // Modify response after receiving\n *     onResponse: (context) => {\n *       context.result.data = {\n *         ...context.result.data,\n *         customData: 'value'\n *       };\n *       return context;\n *     }\n *   }\n * });\n *\n * // Make HTTP requests\n * const data = await api.get('/users');\n *\n * // Use Helpers, eg. access instance configuration\n * const config = api.helpers.getConfig();\n * ```\n */\nexport function createInstance(instanceConfig: Partial<Config> = {}) {\n  const instanceConfigWithDefaults = { ...defaultConfig, ...instanceConfig };\n  const { onRequest, onResponse, onError } =\n    instanceConfigWithDefaults.hooks || {};\n\n  const interceptor = (\n    method: METHODS,\n    url: string,\n    options: RequestOptions,\n  ): CancelablePromise<RequestResult> => {\n    let context: Context = {\n      config: instanceConfigWithDefaults,\n      request: {\n        method,\n        url,\n        options: {\n          ...instanceConfigWithDefaults,\n          ...options,\n          headers: {\n            ...instanceConfigWithDefaults.headers,\n            ...(options.headers || {}),\n          },\n        },\n      },\n      result: null,\n      error: null,\n      // Helper methods for easier manipulation\n      setHeaders: (\n        updater: (headers: {\n          [key: string]: string;\n        }) => { [key: string]: string } | void,\n      ) => {\n        const currentHeaders = context.request.options.headers || {};\n        const result = updater(currentHeaders);\n        if (result) {\n          context.request.options.headers = result;\n        }\n      },\n      setBody: (body: any) => {\n        context.request.options.body = body;\n      },\n      setOptions: (\n        updater: (options: RequestOptions) => RequestOptions | void,\n      ) => {\n        const result = updater(context.request.options);\n        if (result) {\n          context.request.options = result;\n        }\n      },\n      setUrl: (url: string) => {\n        context.request.url = url;\n      },\n      setMethod: (method: METHODS) => {\n        context.request.method = method;\n      },\n      setError: (\n        error: { message: string; status: string | number } | null,\n      ) => {\n        context.error = error;\n      },\n    };\n\n    const applyPatch = (original: Context, patch?: DeepPartial<Context>) => {\n      if (!patch) return original;\n      const updated = {\n        ...original,\n        ...patch,\n        request: {\n          ...original.request,\n          ...patch.request,\n          options: {\n            ...original.request.options,\n            ...patch.request?.options,\n            headers: {\n              ...original.request.options.headers,\n              ...(patch.request?.options?.headers || {}),\n            },\n          },\n        },\n        result: patch.result ?? original.result,\n        error: patch.error ?? original.error,\n        // Preserve helper methods\n        setHeaders: original.setHeaders,\n        setBody: original.setBody,\n        setOptions: original.setOptions,\n        setUrl: original.setUrl,\n        setMethod: original.setMethod,\n        setError: original.setError,\n      } as Context;\n\n      // Update the helper methods to work with the new context\n      updated.setHeaders = (\n        updater: (headers: {\n          [key: string]: string;\n        }) => { [key: string]: string } | void,\n      ) => {\n        const currentHeaders = updated.request.options.headers || {};\n        const result = updater(currentHeaders);\n        if (result) {\n          updated.request.options.headers = result;\n        }\n      };\n      updated.setBody = (body: any) => {\n        updated.request.options.body = body;\n      };\n      updated.setOptions = (\n        updater: (options: RequestOptions) => RequestOptions | void,\n      ) => {\n        const result = updater(updated.request.options);\n        if (result) {\n          updated.request.options = result;\n        }\n      };\n      updated.setUrl = (url: string) => {\n        updated.request.url = url;\n      };\n      updated.setMethod = (method: METHODS) => {\n        updated.request.method = method;\n      };\n      updated.setError = (\n        error: { message: string; status: string | number } | null,\n      ) => {\n        updated.error = error;\n      };\n\n      return updated;\n    };\n\n    let basePromise: CancelablePromise<RequestResult> | null = null;\n\n    const runner = async (): Promise<RequestResult> => {\n      if (onRequest) {\n        const patch = await onRequest(context);\n        if (patch) {\n          context = applyPatch(context, patch);\n        }\n      }\n\n      basePromise = request(context.request.url, context.request.method, {\n        ...context.request.options,\n        hooks: { onError },\n      });\n\n      const result = await basePromise;\n      context.result = result;\n\n      if (onResponse) {\n        const patch = await onResponse(context);\n        if (patch) {\n          context = applyPatch(context, patch);\n        }\n      }\n\n      return context.result!;\n    };\n\n    const promise = new Promise<RequestResult>(async (resolve, reject) => {\n      try {\n        const res = await runner();\n        resolve(res);\n      } catch (error) {\n        reject(error);\n      }\n    }) as CancelablePromise<RequestResult>;\n\n    promise.cancel = () => {\n      basePromise?.cancel();\n    };\n\n    return promise;\n  };\n\n  const createMethod = (method: METHODS) => {\n    return (url: string, options?: RequestOptions) =>\n      interceptor(method, url, options || {});\n  };\n\n  const get = createMethod(\"GET\");\n  const post = createMethod(\"POST\");\n  const put = createMethod(\"PUT\");\n  const delete_ = createMethod(\"DELETE\");\n  const patch = createMethod(\"PATCH\");\n  const options_ = createMethod(\"OPTIONS\");\n  const trace = createMethod(\"TRACE\");\n  const head = createMethod(\"HEAD\");\n  const custom = (url: string, method: string, options?: RequestOptions) =>\n    interceptor(method as METHODS, url, options || {});\n  const setBearerToken = (token: string) => {\n    instanceConfigWithDefaults.bearerToken = token;\n    instanceConfigWithDefaults.headers[\"Authorization\"] = `Bearer ${token}`;\n  };\n\n  return {\n    get,\n    post,\n    put,\n    delete: delete_,\n    patch,\n    options: options_,\n    trace,\n    head,\n    custom,\n    helpers: {\n      getConfig: () => instanceConfigWithDefaults,\n      setBearerToken,\n    },\n  };\n}\n"]}