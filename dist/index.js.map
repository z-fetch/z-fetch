{"version":3,"sources":["../src/lib/index.ts"],"names":["error","result","url","method","patch"],"mappings":"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","file":"index.js","sourcesContent":["export type METHODS =\n  | \"GET\"\n  | \"POST\"\n  | \"PUT\"\n  | \"DELETE\"\n  | \"PATCH\"\n  | \"OPTIONS\"\n  | \"TRACE\"\n  | \"HEAD\"\n  | \"CUSTOM\"\n  | string;\n\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\nexport type Hook = (\n  context: Context,\n) => Promise<DeepPartial<Context> | void> | DeepPartial<Context> | void;\n\nexport type Context = {\n  config: Config;\n  request: {\n    method: METHODS;\n    url: string;\n    options: RequestOptions;\n  };\n  result: RequestResult | null;\n  error: { message: string; status: string | number } | null;\n  // Helper methods for easier manipulation\n  setHeaders: (updater: (headers: { [key: string]: string }) => { [key: string]: string } | void) => void;\n  setBody: (body: any) => void;\n  setOptions: (updater: (options: RequestOptions) => RequestOptions | void) => void;\n  setUrl: (url: string) => void;\n  setMethod: (method: METHODS) => void;\n  setError: (error: { message: string; status: string | number } | null) => void;\n};\n\nexport type Config = {\n  baseUrl: string;\n  bearerToken: string | null;\n  timeout: number;\n  retry: boolean;\n  maxRetries: number;\n  startPolling: boolean;\n  stopPolling: boolean;\n  pollingInterval: number;\n  revalidateCache: number;\n  withCredentials: boolean;\n  withCache: boolean;\n  parseJson: boolean;\n  stringifyPayload: boolean;\n  mode: RequestMode;\n  headers: { [key: string]: string };\n  hooks: {\n    onRequest?: Hook;\n    onResponse?: Hook;\n    onError?: Hook;\n  };\n  errorMapping?: {\n    [statusCode: number]: string;\n    [statusPattern: string]: string;\n  };\n  // Progress tracking options\n  onUploadProgress?: (event: ProgressEvent) => void;\n  onDownloadProgress?: (event: ProgressEvent) => void;\n  useXHRForProgress?: boolean; // Force XMLHttpRequest when progress callbacks are provided\n};\n\nexport type RequestResult = {\n  loading: boolean;\n  error: { message: string; status: string | number } | null;\n  data: any;\n  response: Response | null;\n  refetch: (callback: (result: RequestResult) => void) => Promise<any>;\n  cancelRequest: () => void;\n  startPolling: (interval?: number) => void;\n  stopPolling: () => void;\n  onPollDataReceived: (callback: (result: RequestResult) => void) => void;\n  // Streaming utilities\n  streamToString?: () => Promise<string>;\n  streamToBlob?: () => Promise<Blob>;\n  streamToArrayBuffer?: () => Promise<ArrayBuffer>;\n  streamChunks?: (callback: (chunk: Uint8Array) => void) => Promise<void>;\n};\n\nexport type RequestOptions = Omit<RequestInit, \"body\"> & {\n  body?: BodyInit | object | null;\n} & Partial<Config>;\n\nexport const defaultConfig: Config = {\n  baseUrl: \"\",\n  bearerToken: null,\n  timeout: 90000,\n  retry: false,\n  maxRetries: 3,\n  startPolling: false,\n  stopPolling: false,\n  pollingInterval: 5000,\n  revalidateCache: 10000,\n  withCredentials: false,\n  withCache: true,\n  parseJson: true,\n  stringifyPayload: true,\n  mode: \"cors\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Accept: \"*/*\",\n  },\n  hooks: {},\n  errorMapping: {},\n  useXHRForProgress: false,\n};\n\nlet config: Config = { ...defaultConfig };\n\nconst cache: Map<string, RequestResult> = new Map();\n\n// XMLHttpRequest-based request for progress tracking\nasync function requestWithProgress(\n  url: string,\n  method: METHODS,\n  options: RequestOptions = { ...defaultConfig },\n  context?: { config: Config; onError?: Hook },\n): Promise<{\n  loading: boolean;\n  error: { message: string; status: string | number } | null;\n  data: any;\n  response: Response | null;\n}> {\n  return new Promise((resolve) => {\n    const mergedConfig = { ...config, ...options };\n    let fullUrl = mergedConfig.baseUrl ? mergedConfig.baseUrl + url : url;\n    \n    const xhr = new XMLHttpRequest();\n    \n    // Setup upload progress tracking\n    if (mergedConfig.onUploadProgress && xhr.upload) {\n      xhr.upload.addEventListener('progress', mergedConfig.onUploadProgress);\n    }\n    \n    // Setup download progress tracking\n    if (mergedConfig.onDownloadProgress) {\n      xhr.addEventListener('progress', mergedConfig.onDownloadProgress);\n    }\n    \n    const handleError = async (error: { message: string; status: string | number }) => {\n      if (context?.onError && context.config) {\n        const errorContext = {\n          config: context.config,\n          request: {\n            method,\n            url,\n            options: mergedConfig,\n          },\n          result: null,\n          error,\n          setHeaders: () => {},\n          setBody: () => {},\n          setOptions: () => {},\n          setUrl: () => {},\n          setMethod: () => {},\n          setError: (newError: { message: string; status: string | number } | null) => {\n            error = newError || error;\n          },\n        };\n        \n        const patch = await context.onError(errorContext);\n        if (patch?.error !== undefined) {\n          error = patch.error || error;\n        }\n      }\n      return error;\n    };\n    \n    xhr.addEventListener('loadend', async () => {\n      let error: { message: string; status: string | number } | null = null;\n      let data: any = null;\n      let response: Response | null = null;\n      \n      if (xhr.status >= 200 && xhr.status < 300) {\n        try {\n          data = mergedConfig.parseJson ? JSON.parse(xhr.responseText) : xhr.responseText;\n          // Create a mock Response object for compatibility\n          response = {\n            ok: true,\n            status: xhr.status,\n            statusText: xhr.statusText,\n            url: fullUrl,\n            headers: new Headers(),\n            json: async () => mergedConfig.parseJson ? JSON.parse(xhr.responseText) : xhr.responseText,\n            text: async () => xhr.responseText,\n            blob: async () => new Blob([xhr.response]),\n            arrayBuffer: async () => xhr.response,\n            formData: async () => new FormData(),\n            body: null,\n            bodyUsed: false,\n            clone: function() { return this; },\n            type: 'basic',\n            redirected: false\n          } as Response;\n        } catch (err) {\n          error = { message: 'Failed to parse response', status: 'PARSE_ERROR' };\n          error = await handleError(error);\n        }\n      } else {\n        const originalMessage = xhr.statusText;\n        let mappedMessage = originalMessage;\n        \n        // Apply error mapping if configured\n        if (mergedConfig.errorMapping) {\n          // Check for exact status code match\n          if (mergedConfig.errorMapping[xhr.status]) {\n            mappedMessage = mergedConfig.errorMapping[xhr.status];\n          } else {\n            // Check for pattern matches\n            for (const [pattern, message] of Object.entries(mergedConfig.errorMapping)) {\n              if (typeof pattern === 'string') {\n                if (pattern === xhr.status.toString()) {\n                  mappedMessage = message;\n                  break;\n                }\n                if (originalMessage.toLowerCase().includes(pattern.toLowerCase()) ||\n                    xhr.status.toString().includes(pattern)) {\n                  mappedMessage = message;\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        error = { message: mappedMessage, status: xhr.status };\n        error = await handleError(error);\n      }\n      \n      resolve({ loading: false, error, data, response });\n    });\n    \n    xhr.addEventListener('error', async () => {\n      let mappedMessage = 'Network error';\n      \n      // Apply error mapping for network errors if configured\n      if (mergedConfig.errorMapping) {\n        for (const [pattern, message] of Object.entries(mergedConfig.errorMapping)) {\n          if (typeof pattern === 'string') {\n            if (pattern.toLowerCase() === 'network_error' ||\n                pattern.toLowerCase() === 'fetch failed') {\n              mappedMessage = message;\n              break;\n            }\n          }\n        }\n      }\n      \n      let error: { message: string; status: string | number } = { message: mappedMessage, status: 'NETWORK_ERROR' };\n      const handledError = await handleError(error);\n      error = handledError || error;\n      \n      resolve({ \n        loading: false, \n        error, \n        data: null, \n        response: null \n      });\n    });\n    \n    xhr.addEventListener('timeout', async () => {\n      let error: { message: string; status: string | number } = { message: 'Request timed out!', status: 'TIMEOUT' };\n      const handledError = await handleError(error);\n      error = handledError || error;\n      \n      resolve({ \n        loading: false, \n        error, \n        data: null, \n        response: null \n      });\n    });\n    \n    // Setup the request\n    xhr.open(method, fullUrl);\n    xhr.timeout = mergedConfig.timeout;\n    \n    // Set headers\n    const headers = { ...config.headers, ...(options.headers || {}) };\n    if (mergedConfig.bearerToken && !headers[\"Authorization\"]) {\n      headers[\"Authorization\"] = `Bearer ${mergedConfig.bearerToken}`;\n    }\n    \n    Object.entries(headers).forEach(([key, value]) => {\n      xhr.setRequestHeader(key, String(value));\n    });\n    \n    // Set credentials\n    if (mergedConfig.withCredentials) {\n      xhr.withCredentials = true;\n    }\n    \n    // Send the request\n    let body: any = null;\n    if (mergedConfig.body !== undefined) {\n      if (typeof mergedConfig.body === \"object\" && mergedConfig.body !== null) {\n        body = mergedConfig.stringifyPayload ? JSON.stringify(mergedConfig.body) : mergedConfig.body;\n      } else {\n        body = mergedConfig.body;\n      }\n    }\n    \n    xhr.send(body);\n  });\n}\n\nasync function request(\n  url: string,\n  method: METHODS,\n  options: RequestOptions = { ...defaultConfig },\n): Promise<RequestResult> {\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  let loading = true;\n  let error: { message: string; status: string | number } | null = null;\n  let data: any = null;\n  let retryCount = 0;\n\n  // Merge configuration properly\n  const mergedConfig = { ...config, ...options };\n  let fullUrl = mergedConfig.baseUrl ? mergedConfig.baseUrl + url : url;\n\n  // Check if we should use XMLHttpRequest for progress tracking\n  const shouldUseXHR = mergedConfig.useXHRForProgress || \n                       mergedConfig.onUploadProgress || \n                       mergedConfig.onDownloadProgress;\n\n  const timeoutId = setTimeout(() => {\n    abortController.abort();\n    loading = true;\n    error = { message: \"Request timed out!\", status: \"TIMEOUT\" };\n  }, mergedConfig.timeout);\n\n  const performRequest = async (): Promise<{\n    loading: boolean;\n    error: typeof error;\n    data: any;\n    response: Response | null;\n  }> => {\n    // Use XMLHttpRequest if progress tracking is needed\n    if (shouldUseXHR) {\n      return await requestWithProgress(url, method, options, {\n        config: mergedConfig,\n        onError: mergedConfig.hooks?.onError,\n      });\n    }\n    \n    const handleError = async (error: { message: string; status: string | number }) => {\n      if (mergedConfig.hooks?.onError) {\n        const errorContext = {\n          config: mergedConfig,\n          request: {\n            method,\n            url,\n            options: mergedConfig,\n          },\n          result: null,\n          error,\n          setHeaders: () => {},\n          setBody: () => {},\n          setOptions: () => {},\n          setUrl: () => {},\n          setMethod: () => {},\n          setError: (newError: { message: string; status: string | number } | null) => {\n            error = newError || error;\n          },\n        };\n        \n        const patch = await mergedConfig.hooks.onError(errorContext);\n        if (patch?.error !== undefined) {\n          error = patch.error || error;\n        }\n      }\n      return error;\n    };\n    \n    try {\n      // Handle bearerToken option - but don't override explicit Authorization header\n      const headers = { ...config.headers, ...(options.headers || {}) };\n      if (mergedConfig.bearerToken && !headers[\"Authorization\"]) {\n        headers[\"Authorization\"] = `Bearer ${mergedConfig.bearerToken}`;\n      }\n\n      // Only pass valid fetch options, excluding z-fetch specific config\n      let fetchOptions: RequestInit = {\n        signal,\n        method,\n        headers,\n      };\n\n      // Add valid fetch options from merged config\n      if (mergedConfig.body !== undefined) {\n        if (typeof mergedConfig.body === \"object\" && mergedConfig.body !== null) {\n          fetchOptions.body = mergedConfig.stringifyPayload ? JSON.stringify(mergedConfig.body) : mergedConfig.body as BodyInit;\n        } else {\n          fetchOptions.body = mergedConfig.body as BodyInit;\n        }\n      }\n      if (mergedConfig.cache !== undefined) fetchOptions.cache = mergedConfig.cache;\n      if (mergedConfig.credentials !== undefined) fetchOptions.credentials = mergedConfig.credentials;\n      if (mergedConfig.withCredentials) fetchOptions.credentials = 'include';\n      if (mergedConfig.integrity !== undefined) fetchOptions.integrity = mergedConfig.integrity;\n      if (mergedConfig.keepalive !== undefined) fetchOptions.keepalive = mergedConfig.keepalive;\n      if (mergedConfig.mode !== undefined) fetchOptions.mode = mergedConfig.mode;\n      if (mergedConfig.redirect !== undefined) fetchOptions.redirect = mergedConfig.redirect;\n      if (mergedConfig.referrer !== undefined) fetchOptions.referrer = mergedConfig.referrer;\n      if (mergedConfig.referrerPolicy !== undefined) fetchOptions.referrerPolicy = mergedConfig.referrerPolicy;\n\n      if (mergedConfig.referrerPolicy !== undefined) fetchOptions.referrerPolicy = mergedConfig.referrerPolicy;\n\n      if (options.baseUrl) {\n        fullUrl = options.baseUrl + url;\n      }\n\n      const response = await fetch(fullUrl, fetchOptions);\n\n      if (!response.ok) {\n        const originalMessage = response.statusText;\n        let mappedMessage = originalMessage;\n        \n        // Apply error mapping if configured\n        if (mergedConfig.errorMapping) {\n          // Check for exact status code match\n          if (mergedConfig.errorMapping[response.status]) {\n            mappedMessage = mergedConfig.errorMapping[response.status];\n          } else {\n            // Check for pattern matches\n            for (const [pattern, message] of Object.entries(mergedConfig.errorMapping)) {\n              if (typeof pattern === 'string') {\n                // Check if status code matches pattern\n                if (pattern === response.status.toString()) {\n                  mappedMessage = message;\n                  break;\n                }\n                // Check if original message contains pattern (case insensitive)\n                if (originalMessage.toLowerCase().includes(pattern.toLowerCase()) ||\n                    response.status.toString().includes(pattern)) {\n                  mappedMessage = message;\n                  break;\n                }\n              }\n            }\n          }\n        }\n        \n        error = { message: mappedMessage, status: response.status };\n        error = await handleError(error);\n      } else {\n        // Clone response for data extraction to preserve body for streaming utilities\n        const responseForData = response.clone();\n        data = mergedConfig.parseJson ? await responseForData.json() : await responseForData.text();\n      }\n\n      clearTimeout(timeoutId);\n      loading = false;\n      return { loading, error, data, response };\n    } catch (err: any) {\n      let mappedMessage = err.message;\n      \n      // Apply error mapping for network errors if configured\n      if (mergedConfig.errorMapping) {\n        for (const [pattern, message] of Object.entries(mergedConfig.errorMapping)) {\n          if (typeof pattern === 'string') {\n            if (err.message.toLowerCase().includes(pattern.toLowerCase()) ||\n                pattern.toLowerCase() === 'network_error' ||\n                pattern.toLowerCase() === 'fetch failed') {\n              mappedMessage = message;\n              break;\n            }\n          }\n        }\n      }\n      \n      error = { message: mappedMessage, status: \"NETWORK_ERROR\" };\n      error = await handleError(error);\n      clearTimeout(timeoutId);\n      loading = false;\n      return { loading, error, data, response: null };\n    }\n  };\n\n  const refetch = async (\n    callback: (result: RequestResult) => void,\n  ): Promise<any> => {\n    const newData = await performRequest();\n    return callback({\n      ...newData,\n      refetch,\n      cancelRequest,\n      startPolling,\n      stopPolling,\n      onPollDataReceived,\n    });\n  };\n\n  const cancelRequest = (): void => {\n    abortController.abort();\n  };\n\n  let result = await performRequest();\n\n  while (config.retry && retryCount < config.maxRetries && result.error) {\n    retryCount++;\n    result = await performRequest();\n  }\n\n  let pollingIntervalId: any | null = null;\n  let pollCallback: ((result: RequestResult) => void) | null = null;\n\n  const stopPolling = (): void => {\n    if (pollingIntervalId) {\n      clearInterval(pollingIntervalId);\n      pollingIntervalId = null;\n    }\n  };\n\n  const onPollDataReceived = (\n    callback: (result: RequestResult) => void,\n  ): void => {\n    if (typeof callback !== \"function\") {\n      throw new Error(\"onPollDataReceived callback must be a function\");\n    }\n    pollCallback = callback;\n    // Start polling if it was requested but delayed due to missing callback\n    if (config.startPolling && !pollingIntervalId) {\n      startPolling();\n    }\n  };\n\n  const startPolling = (interval: number = config.pollingInterval): void => {\n    if (!pollCallback) {\n      console.warn(\"Polling not started: onPollDataReceived callback not set\");\n      return;\n    }\n    if (pollingIntervalId) {\n      stopPolling(); // Clear existing interval if any\n    }\n    pollingIntervalId = setInterval(async () => {\n      try {\n        const newResult = await performRequest();\n        pollCallback!(newResult as RequestResult);\n        Object.assign(result, newResult);\n      } catch (pollError) {\n        console.error(\"Polling error:\", pollError);\n      }\n    }, interval);\n  };\n\n  // Streaming utility functions\n  const streamToString = async (): Promise<string> => {\n    if (!result.response) {\n      throw new Error('No response available for streaming');\n    }\n    if (typeof result.response.text !== 'function') {\n      throw new Error('No response body available for streaming');\n    }\n    try {\n      return await result.response.text();\n    } catch (error) {\n      throw new Error('Failed to read response as text');\n    }\n  };\n\n  const streamToBlob = async (): Promise<Blob> => {\n    if (!result.response) {\n      throw new Error('No response available for streaming');\n    }\n    if (typeof result.response.blob !== 'function') {\n      throw new Error('No response body available for streaming');\n    }\n    try {\n      return await result.response.blob();\n    } catch (error) {\n      throw new Error('Failed to read response as blob');\n    }\n  };\n\n  const streamToArrayBuffer = async (): Promise<ArrayBuffer> => {\n    if (!result.response) {\n      throw new Error('No response available for streaming');\n    }\n    if (typeof result.response.arrayBuffer !== 'function') {\n      throw new Error('No response body available for streaming');\n    }\n    try {\n      return await result.response.arrayBuffer();\n    } catch (error) {\n      throw new Error('Failed to read response as array buffer');\n    }\n  };\n\n  const streamChunks = async (callback: (chunk: Uint8Array) => void): Promise<void> => {\n    if (!result.response) {\n      throw new Error('No response available for streaming');\n    }\n    if (!result.response.body) {\n      throw new Error('No response body available for streaming');\n    }\n    \n    try {\n      const reader = result.response.body.getReader();\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n          callback(value);\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    } catch (error) {\n      throw new Error('Failed to read response stream');\n    }\n  };\n\n  // Check cache for GET requests\n  const cacheKey = `${method}:${fullUrl}`;\n  if (config.withCache && method === \"GET\" && cache.has(cacheKey)) {\n    setTimeout(() => {\n      performRequest().then((newResult) => {\n        if (!newResult.error) {\n          cache.set(cacheKey, {\n            ...newResult,\n            refetch,\n            cancelRequest,\n            startPolling,\n            stopPolling,\n            onPollDataReceived,\n          });\n        }\n      });\n    }, config.revalidateCache);\n    return cache.get(cacheKey)!;\n  }\n\n  // Cache successful GET requests\n  if (config.withCache && method === \"GET\" && !result.error) {\n    cache.set(cacheKey, {\n      ...result,\n      refetch,\n      cancelRequest,\n      startPolling,\n      stopPolling,\n      onPollDataReceived,\n      streamToString,\n      streamToBlob,\n      streamToArrayBuffer,\n      streamChunks,\n    });\n  }\n\n  return {\n    ...result,\n    refetch,\n    cancelRequest,\n    startPolling,\n    stopPolling,\n    onPollDataReceived,\n    streamToString,\n    streamToBlob,\n    streamToArrayBuffer,\n    streamChunks,\n  };\n}\n\n/**\n * Sends an HTTP GET request to the specified URL.\n *\n * @param url - The target URL to send the GET request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await GET('https://api.example.com/resource');\n */\nexport function GET(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"GET\", options);\n}\n\n/**\n * Sends an HTTP POST request to the specified URL.\n *\n * @param url - The target URL to send the POST request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await POST('https://api.example.com/resource', { body: { key: 'value' } });\n */\nexport function POST(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"POST\", options);\n}\n\n/**\n * Sends an HTTP PUT request to the specified URL.\n *\n * @param url - The target URL to send the PUT request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await PUT('https://api.example.com/resource', { body: { key: 'value' } });\n */\nexport function PUT(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"PUT\", options);\n}\n\n/**\n * Sends an HTTP DELETE request to the specified URL.\n *\n * @param url - The target URL to send the DELETE request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await DELETE('https://api.example.com/resource');\n */\nexport function DELETE(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"DELETE\", options);\n}\n\n/**\n * Sends an HTTP PATCH request to the specified URL.\n *\n * @param url - The target URL to send the PATCH request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n *\n * const result = await PATCH('https://api.example.com/resource', { body: { key: 'value' } });\n *\n */\nexport function PATCH(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"PATCH\", options);\n}\n\n// Additional HTTP methods\n\n/**\n * Sends an HTTP OPTIONS request to the specified URL.\n *\n * @param url - The target URL to send the OPTIONS request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * ```ts\n * const result = await OPTIONS('https://api.example.com/resource');\n * ```\n */\nexport function OPTIONS(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"OPTIONS\", options);\n}\n\n/**\n * Sends a TRACE request to the specified URL.\n *\n * The TRACE method performs a message loop-back test along the path to the target resource.\n *\n * @param url - The URL to send the TRACE request to\n * @param options - Optional request configuration options\n * @returns A Promise that resolves to the response from the request\n * @throws {Error} If the request fails or network error occurs\n */\nexport function TRACE(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"TRACE\", options);\n}\n\n/**\n * Performs an HTTP HEAD request to the specified URL.\n *\n * @param url - The URL to send the HEAD request to\n * @param options - Optional configuration for the request\n * @returns A Promise that resolves with the response data\n *\n * @example\n * ```typescript\n * const result = await HEAD('https://api.example.com/resource');\n * ```\n */\nexport function HEAD(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"HEAD\", options);\n}\n\n/**\n * CUSTOM method allows you to specify any HTTP method.\n * @param {string} url - The URL to request\n * @param {string} method - The HTTP method (e.g. \"CONNECT\", \"CUSTOM\", etc.)\n * @param {RequestOptions} [options] - Additional options for the request\n * @returns {Promise<RequestResult>} The request result\n */\nexport function CUSTOM(\n  url: string,\n  method: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, method, options);\n}\n\n/**\n * Creates a new Z-Fetch instance with custom configuration.\n *\n * @param instanceConfig - Optional configuration object to override default settings\n * @returns An object containing HTTP methods (get, post, etc.) and helper utilities\n *\n * @example\n * ```typescript\n * // Create a new instance with custom config\n * const api = createInstance({\n *   baseUrl: 'https://api.example.com',\n *   headers: { 'Content-Type': 'application/json' },\n *   hooks: {\n *     // Modify request before sending\n *     onRequest: (context) => {\n *       context.request.options.headers['X-Custom-Header'] = 'value';\n *       return context;\n *     },\n *\n *     // Modify response after receiving\n *     onResponse: (context) => {\n *       context.result.data = {\n *         ...context.result.data,\n *         customData: 'value'\n *       };\n *       return context;\n *     }\n *   }\n * });\n *\n * // Make HTTP requests\n * const data = await api.get('/users');\n *\n * // Use Helpers, eg. access instance configuration\n * const config = api.helpers.getConfig();\n * ```\n */\nexport function createInstance(instanceConfig: Partial<Config> = {}) {\n  const instanceConfigWithDefaults = { ...defaultConfig, ...instanceConfig };\n  const { onRequest, onResponse, onError } = instanceConfigWithDefaults.hooks || {};\n\n  const interceptor = async (\n    method: METHODS,\n    url: string,\n    options: RequestOptions,\n  ): Promise<RequestResult> => {\n    let context: Context = {\n      config: instanceConfigWithDefaults,\n      request: {\n        method,\n        url,\n        options: { \n          ...instanceConfigWithDefaults, \n          ...options,\n          headers: { ...instanceConfigWithDefaults.headers, ...(options.headers || {}) }\n        },\n      },\n      result: null,\n      error: null,\n      // Helper methods for easier manipulation\n      setHeaders: (updater: (headers: { [key: string]: string }) => { [key: string]: string } | void) => {\n        const currentHeaders = context.request.options.headers || {};\n        const result = updater(currentHeaders);\n        if (result) {\n          context.request.options.headers = result;\n        }\n      },\n      setBody: (body: any) => {\n        context.request.options.body = body;\n      },\n      setOptions: (updater: (options: RequestOptions) => RequestOptions | void) => {\n        const result = updater(context.request.options);\n        if (result) {\n          context.request.options = result;\n        }\n      },\n      setUrl: (url: string) => {\n        context.request.url = url;\n      },\n      setMethod: (method: METHODS) => {\n        context.request.method = method;\n      },\n      setError: (error: { message: string; status: string | number } | null) => {\n        context.error = error;\n      },\n    };\n\n    const applyPatch = (original: Context, patch?: DeepPartial<Context>) => {\n      if (!patch) return original;\n      const updated = {\n        ...original,\n        ...patch,\n        request: {\n          ...original.request,\n          ...patch.request,\n          options: {\n            ...original.request.options,\n            ...patch.request?.options,\n            headers: {\n              ...original.request.options.headers,\n              ...(patch.request?.options?.headers || {})\n            }\n          }\n        },\n        result: patch.result ?? original.result,\n        error: patch.error ?? original.error,\n        // Preserve helper methods\n        setHeaders: original.setHeaders,\n        setBody: original.setBody,\n        setOptions: original.setOptions,\n        setUrl: original.setUrl,\n        setMethod: original.setMethod,\n        setError: original.setError,\n      } as Context;\n      \n      // Update the helper methods to work with the new context\n      updated.setHeaders = (updater: (headers: { [key: string]: string }) => { [key: string]: string } | void) => {\n        const currentHeaders = updated.request.options.headers || {};\n        const result = updater(currentHeaders);\n        if (result) {\n          updated.request.options.headers = result;\n        }\n      };\n      updated.setBody = (body: any) => {\n        updated.request.options.body = body;\n      };\n      updated.setOptions = (updater: (options: RequestOptions) => RequestOptions | void) => {\n        const result = updater(updated.request.options);\n        if (result) {\n          updated.request.options = result;\n        }\n      };\n      updated.setUrl = (url: string) => {\n        updated.request.url = url;\n      };\n      updated.setMethod = (method: METHODS) => {\n        updated.request.method = method;\n      };\n      updated.setError = (error: { message: string; status: string | number } | null) => {\n        updated.error = error;\n      };\n      \n      return updated;\n    };\n\n    // console.log('context log before::', context.request.options);\n    if (onRequest) {\n      const patch = await onRequest(context);\n      if (patch) {\n        context = applyPatch(context, patch);\n      }\n    }\n\n    // console.log('context log after::', context.request.options);\n\n    const result = await request(\n      context.request.url,\n      context.request.method,\n      { ...context.request.options, hooks: { onError } },\n    );\n\n    context.result = result;\n\n    if (onResponse) {\n      const patch = await onResponse(context);\n      if (patch) {\n        context = applyPatch(context, patch);\n      }\n    }\n\n    return context.result!;\n  };\n\n  const createMethod = (method: METHODS) => {\n    return (url: string, options?: RequestOptions) =>\n      interceptor(method, url, options || {});\n  };\n\n  const get = createMethod(\"GET\");\n  const post = createMethod(\"POST\");\n  const put = createMethod(\"PUT\");\n  const delete_ = createMethod(\"DELETE\");\n  const patch = createMethod(\"PATCH\");\n  const options_ = createMethod(\"OPTIONS\");\n  const trace = createMethod(\"TRACE\");\n  const head = createMethod(\"HEAD\");\n  const custom = (url: string, method: string, options?: RequestOptions) =>\n    interceptor(method as METHODS, url, options || {});\n  const setBearerToken = (token: string) => {\n    instanceConfigWithDefaults.bearerToken = token;\n    instanceConfigWithDefaults.headers[\"Authorization\"] = `Bearer ${token}`;\n  };\n\n  return {\n    get,\n    post,\n    put,\n    delete: delete_,\n    patch,\n    options: options_,\n    trace,\n    head,\n    custom,\n    helpers: {\n      getConfig: () => instanceConfigWithDefaults,\n      setBearerToken,\n    },\n  };\n}\n"]}