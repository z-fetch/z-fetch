{"version":3,"sources":["../src/lib/index.ts"],"names":["error","result","url","method","patch"],"mappings":";AAuRO,IAAM,aAAA,GAAwB;AAAA,EACnC,OAAA,EAAS,EAAA;AAAA,EACT,WAAA,EAAa,IAAA;AAAA,EACb,OAAA,EAAS,GAAA;AAAA,EACT,KAAA,EAAO,KAAA;AAAA,EACP,UAAA,EAAY,CAAA;AAAA,EACZ,YAAA,EAAc,KAAA;AAAA,EACd,WAAA,EAAa,KAAA;AAAA,EACb,eAAA,EAAiB,GAAA;AAAA,EACjB,eAAA,EAAiB,GAAA;AAAA,EACjB,eAAA,EAAiB,KAAA;AAAA,EACjB,SAAA,EAAW,IAAA;AAAA,EACX,SAAA,EAAW,IAAA;AAAA,EACX,gBAAA,EAAkB,IAAA;AAAA,EAClB,IAAA,EAAM,MAAA;AAAA,EACN,OAAA,EAAS;AAAA,IACP,cAAA,EAAgB,kBAAA;AAAA,IAChB,MAAA,EAAQ;AAAA,GACV;AAAA,EACA,OAAO,EAAC;AAAA,EACR,cAAc,EAAC;AAAA,EACf,iBAAA,EAAmB;AACrB,CAAA;AAEA,IAAI,MAAA,GAAiB,EAAE,GAAG,aAAA,EAAc;AAMxC,IAAM,KAAA,uBAAwC,GAAA,EAAI;AAclD,eAAe,mBAAA,CACb,KACA,MAAA,EACA,OAAA,GAA0B,EAAE,GAAG,aAAA,IAC/B,OAAA,EAMC;AACD,EAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,KAAY;AAC9B,IAAA,MAAM,YAAA,GAAe,EAAE,GAAG,MAAA,EAAQ,GAAG,OAAA,EAAQ;AAC7C,IAAA,IAAI,OAAA,GAAU,YAAA,CAAa,OAAA,GAAU,YAAA,CAAa,UAAU,GAAA,GAAM,GAAA;AAElE,IAAA,MAAM,GAAA,GAAM,IAAI,cAAA,EAAe;AAG/B,IAAA,IAAI,YAAA,CAAa,gBAAA,IAAoB,GAAA,CAAI,MAAA,EAAQ;AAC/C,MAAA,GAAA,CAAI,MAAA,CAAO,gBAAA,CAAiB,UAAA,EAAY,YAAA,CAAa,gBAAgB,CAAA;AAAA,IACvE;AAGA,IAAA,IAAI,aAAa,kBAAA,EAAoB;AACnC,MAAA,GAAA,CAAI,gBAAA,CAAiB,UAAA,EAAY,YAAA,CAAa,kBAAkB,CAAA;AAAA,IAClE;AAEA,IAAA,MAAM,WAAA,GAAc,OAAO,KAAA,KAGrB;AACJ,MAAA,IAAI,OAAA,EAAS,OAAA,IAAW,OAAA,CAAQ,MAAA,EAAQ;AACtC,QAAA,MAAM,YAAA,GAAe;AAAA,UACnB,QAAQ,OAAA,CAAQ,MAAA;AAAA,UAChB,OAAA,EAAS;AAAA,YACP,MAAA;AAAA,YACA,GAAA;AAAA,YACA,OAAA,EAAS;AAAA,WACX;AAAA,UACA,MAAA,EAAQ,IAAA;AAAA,UACR,KAAA;AAAA,UACA,YAAY,MAAM;AAAA,UAAC,CAAA;AAAA,UACnB,SAAS,MAAM;AAAA,UAAC,CAAA;AAAA,UAChB,YAAY,MAAM;AAAA,UAAC,CAAA;AAAA,UACnB,QAAQ,MAAM;AAAA,UAAC,CAAA;AAAA,UACf,WAAW,MAAM;AAAA,UAAC,CAAA;AAAA,UAClB,QAAA,EAAU,CACR,QAAA,KACG;AACH,YAAA,KAAA,GAAQ,QAAA,IAAY,KAAA;AAAA,UACtB;AAAA,SACF;AAEA,QAAA,MAAM,KAAA,GAAQ,MAAM,OAAA,CAAQ,OAAA,CAAQ,YAAY,CAAA;AAChD,QAAA,IAAI,KAAA,EAAO,UAAU,MAAA,EAAW;AAC9B,UAAA,KAAA,GAAQ,MAAM,KAAA,IAAS,KAAA;AAAA,QACzB;AAAA,MACF;AACA,MAAA,OAAO,KAAA;AAAA,IACT,CAAA;AAEA,IAAA,GAAA,CAAI,gBAAA,CAAiB,WAAW,YAAY;AAC1C,MAAA,IAAI,KAAA,GAA6D,IAAA;AACjE,MAAA,IAAI,IAAA,GAAY,IAAA;AAChB,MAAA,IAAI,QAAA,GAA4B,IAAA;AAEhC,MAAA,IAAI,GAAA,CAAI,MAAA,IAAU,GAAA,IAAO,GAAA,CAAI,SAAS,GAAA,EAAK;AACzC,QAAA,IAAI;AACF,UAAA,IAAA,GAAO,aAAa,SAAA,GAChB,IAAA,CAAK,MAAM,GAAA,CAAI,YAAY,IAC3B,GAAA,CAAI,YAAA;AAER,UAAA,QAAA,GAAW;AAAA,YACT,EAAA,EAAI,IAAA;AAAA,YACJ,QAAQ,GAAA,CAAI,MAAA;AAAA,YACZ,YAAY,GAAA,CAAI,UAAA;AAAA,YAChB,GAAA,EAAK,OAAA;AAAA,YACL,OAAA,EAAS,IAAI,OAAA,EAAQ;AAAA,YACrB,IAAA,EAAM,YACJ,YAAA,CAAa,SAAA,GACT,KAAK,KAAA,CAAM,GAAA,CAAI,YAAY,CAAA,GAC3B,GAAA,CAAI,YAAA;AAAA,YACV,IAAA,EAAM,YAAY,GAAA,CAAI,YAAA;AAAA,YACtB,MAAM,YAAY,IAAI,KAAK,CAAC,GAAA,CAAI,QAAQ,CAAC,CAAA;AAAA,YACzC,WAAA,EAAa,YAAY,GAAA,CAAI,QAAA;AAAA,YAC7B,QAAA,EAAU,YAAY,IAAI,QAAA,EAAS;AAAA,YACnC,IAAA,EAAM,IAAA;AAAA,YACN,QAAA,EAAU,KAAA;AAAA,YACV,OAAO,WAAY;AACjB,cAAA,OAAO,IAAA;AAAA,YACT,CAAA;AAAA,YACA,IAAA,EAAM,OAAA;AAAA,YACN,UAAA,EAAY;AAAA,WACd;AAAA,QACF,CAAA,CAAA,MAAQ;AACN,UAAA,KAAA,GAAQ;AAAA,YACN,OAAA,EAAS,0BAAA;AAAA,YACT,MAAA,EAAQ;AAAA,WACV;AACA,UAAA,KAAA,GAAQ,MAAM,YAAY,KAAK,CAAA;AAAA,QACjC;AAAA,MACF,CAAA,MAAO;AACL,QAAA,MAAM,kBAAkB,GAAA,CAAI,UAAA;AAC5B,QAAA,IAAI,aAAA,GAAgB,eAAA;AAGpB,QAAA,IAAI,aAAa,YAAA,EAAc;AAE7B,UAAA,IAAI,YAAA,CAAa,YAAA,CAAa,GAAA,CAAI,MAAM,CAAA,EAAG;AACzC,YAAA,aAAA,GAAgB,YAAA,CAAa,YAAA,CAAa,GAAA,CAAI,MAAM,CAAA;AAAA,UACtD,CAAA,MAAO;AAEL,YAAA,KAAA,MAAW,CAAC,OAAA,EAAS,OAAO,CAAA,IAAK,MAAA,CAAO,OAAA;AAAA,cACtC,YAAA,CAAa;AAAA,aACf,EAAG;AACD,cAAA,IAAI,OAAO,YAAY,QAAA,EAAU;AAC/B,gBAAA,IAAI,OAAA,KAAY,GAAA,CAAI,MAAA,CAAO,QAAA,EAAS,EAAG;AACrC,kBAAA,aAAA,GAAgB,OAAA;AAChB,kBAAA;AAAA,gBACF;AACA,gBAAA,IACE,eAAA,CACG,WAAA,EAAY,CACZ,QAAA,CAAS,QAAQ,WAAA,EAAa,CAAA,IACjC,GAAA,CAAI,MAAA,CAAO,QAAA,EAAS,CAAE,QAAA,CAAS,OAAO,CAAA,EACtC;AACA,kBAAA,aAAA,GAAgB,OAAA;AAChB,kBAAA;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,QAAA,KAAA,GAAQ,EAAE,OAAA,EAAS,aAAA,EAAe,MAAA,EAAQ,IAAI,MAAA,EAAO;AACrD,QAAA,KAAA,GAAQ,MAAM,YAAY,KAAK,CAAA;AAAA,MACjC;AAEA,MAAA,OAAA,CAAQ,EAAE,OAAA,EAAS,KAAA,EAAO,KAAA,EAAO,IAAA,EAAM,UAAU,CAAA;AAAA,IACnD,CAAC,CAAA;AAED,IAAA,GAAA,CAAI,gBAAA,CAAiB,SAAS,YAAY;AACxC,MAAA,IAAI,aAAA,GAAgB,eAAA;AAGpB,MAAA,IAAI,aAAa,YAAA,EAAc;AAC7B,QAAA,KAAA,MAAW,CAAC,OAAA,EAAS,OAAO,CAAA,IAAK,MAAA,CAAO,OAAA;AAAA,UACtC,YAAA,CAAa;AAAA,SACf,EAAG;AACD,UAAA,IAAI,OAAO,YAAY,QAAA,EAAU;AAC/B,YAAA,IACE,QAAQ,WAAA,EAAY,KAAM,mBAC1B,OAAA,CAAQ,WAAA,OAAkB,cAAA,EAC1B;AACA,cAAA,aAAA,GAAgB,OAAA;AAChB,cAAA;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,MAAA,IAAI,KAAA,GAAsD;AAAA,QACxD,OAAA,EAAS,aAAA;AAAA,QACT,MAAA,EAAQ;AAAA,OACV;AACA,MAAA,MAAM,YAAA,GAAe,MAAM,WAAA,CAAY,KAAK,CAAA;AAC5C,MAAA,KAAA,GAAQ,YAAA,IAAgB,KAAA;AAExB,MAAA,OAAA,CAAQ;AAAA,QACN,OAAA,EAAS,KAAA;AAAA,QACT,KAAA;AAAA,QACA,IAAA,EAAM,IAAA;AAAA,QACN,QAAA,EAAU;AAAA,OACX,CAAA;AAAA,IACH,CAAC,CAAA;AAED,IAAA,GAAA,CAAI,gBAAA,CAAiB,WAAW,YAAY;AAC1C,MAAA,IAAI,KAAA,GAAsD;AAAA,QACxD,OAAA,EAAS,oBAAA;AAAA,QACT,MAAA,EAAQ;AAAA,OACV;AACA,MAAA,MAAM,YAAA,GAAe,MAAM,WAAA,CAAY,KAAK,CAAA;AAC5C,MAAA,KAAA,GAAQ,YAAA,IAAgB,KAAA;AAExB,MAAA,OAAA,CAAQ;AAAA,QACN,OAAA,EAAS,KAAA;AAAA,QACT,KAAA;AAAA,QACA,IAAA,EAAM,IAAA;AAAA,QACN,QAAA,EAAU;AAAA,OACX,CAAA;AAAA,IACH,CAAC,CAAA;AAGD,IAAA,GAAA,CAAI,IAAA,CAAK,QAAQ,OAAO,CAAA;AACxB,IAAA,GAAA,CAAI,UAAU,YAAA,CAAa,OAAA;AAG3B,IAAA,MAAM,OAAA,GAAU,EAAE,GAAG,MAAA,CAAO,SAAS,GAAI,OAAA,CAAQ,OAAA,IAAW,EAAC,EAAG;AAChE,IAAA,IAAI,YAAA,CAAa,WAAA,IAAe,CAAC,OAAA,CAAQ,eAAe,CAAA,EAAG;AACzD,MAAA,OAAA,CAAQ,eAAe,CAAA,GAAI,CAAA,OAAA,EAAU,YAAA,CAAa,WAAW,CAAA,CAAA;AAAA,IAC/D;AAEA,IAAA,MAAA,CAAO,OAAA,CAAQ,OAAO,CAAA,CAAE,OAAA,CAAQ,CAAC,CAAC,GAAA,EAAK,KAAK,CAAA,KAAM;AAChD,MAAA,GAAA,CAAI,gBAAA,CAAiB,GAAA,EAAK,MAAA,CAAO,KAAK,CAAC,CAAA;AAAA,IACzC,CAAC,CAAA;AAGD,IAAA,IAAI,aAAa,eAAA,EAAiB;AAChC,MAAA,GAAA,CAAI,eAAA,GAAkB,IAAA;AAAA,IACxB;AAGA,IAAA,IAAI,IAAA,GAAY,IAAA;AAChB,IAAA,IAAI,YAAA,CAAa,SAAS,MAAA,EAAW;AACnC,MAAA,IAAI,OAAO,YAAA,CAAa,IAAA,KAAS,QAAA,IAAY,YAAA,CAAa,SAAS,IAAA,EAAM;AACvE,QAAA,IAAA,GAAO,aAAa,gBAAA,GAChB,IAAA,CAAK,UAAU,YAAA,CAAa,IAAI,IAChC,YAAA,CAAa,IAAA;AAAA,MACnB,CAAA,MAAO;AACL,QAAA,IAAA,GAAO,YAAA,CAAa,IAAA;AAAA,MACtB;AAAA,IACF;AAEA,IAAA,GAAA,CAAI,KAAK,IAAI,CAAA;AAAA,EACf,CAAC,CAAA;AACH;AAcA,eAAe,QACb,GAAA,EACA,MAAA,EACA,UAA0B,EAAE,GAAG,eAAc,EACrB;AACxB,EAAA,MAAM,eAAA,GAAkB,IAAI,eAAA,EAAgB;AAC5C,EAAA,MAAM,EAAE,QAAO,GAAI,eAAA;AAEnB,EAAA,IAAI,OAAA,GAAU,IAAA;AACd,EAAA,IAAI,KAAA,GAA6D,IAAA;AACjE,EAAA,IAAI,IAAA,GAAY,IAAA;AAChB,EAAA,IAAI,UAAA,GAAa,CAAA;AAGjB,EAAA,MAAM,YAAA,GAAe,EAAE,GAAG,MAAA,EAAQ,GAAG,OAAA,EAAQ;AAC7C,EAAA,IAAI,OAAA,GAAU,YAAA,CAAa,OAAA,GAAU,YAAA,CAAa,UAAU,GAAA,GAAM,GAAA;AAGlE,EAAA,MAAM,YAAA,GACJ,YAAA,CAAa,iBAAA,IACb,YAAA,CAAa,oBACb,YAAA,CAAa,kBAAA;AAEf,EAAA,MAAM,SAAA,GAAY,WAAW,MAAM;AACjC,IAAA,eAAA,CAAgB,KAAA,EAAM;AACtB,IAAA,OAAA,GAAU,IAAA;AACV,IAAA,KAAA,GAAQ,EAAE,OAAA,EAAS,oBAAA,EAAsB,MAAA,EAAQ,SAAA,EAAU;AAAA,EAC7D,CAAA,EAAG,aAAa,OAAO,CAAA;AAEvB,EAAA,MAAM,iBAAiB,YAKjB;AAEJ,IAAA,IAAI,YAAA,EAAc;AAChB,MAAA,OAAO,MAAM,mBAAA,CAAoB,GAAA,EAAK,MAAA,EAAQ,OAAA,EAAS;AAAA,QACrD,MAAA,EAAQ,YAAA;AAAA,QACR,OAAA,EAAS,aAAa,KAAA,EAAO;AAAA,OAC9B,CAAA;AAAA,IACH;AAEA,IAAA,MAAM,WAAA,GAAc,OAAOA,MAAAA,KAGrB;AACJ,MAAA,IAAI,YAAA,CAAa,OAAO,OAAA,EAAS;AAC/B,QAAA,MAAM,YAAA,GAAe;AAAA,UACnB,MAAA,EAAQ,YAAA;AAAA,UACR,OAAA,EAAS;AAAA,YACP,MAAA;AAAA,YACA,GAAA;AAAA,YACA,OAAA,EAAS;AAAA,WACX;AAAA,UACA,MAAA,EAAQ,IAAA;AAAA,UACR,KAAA,EAAAA,MAAAA;AAAA,UACA,YAAY,MAAM;AAAA,UAAC,CAAA;AAAA,UACnB,SAAS,MAAM;AAAA,UAAC,CAAA;AAAA,UAChB,YAAY,MAAM;AAAA,UAAC,CAAA;AAAA,UACnB,QAAQ,MAAM;AAAA,UAAC,CAAA;AAAA,UACf,WAAW,MAAM;AAAA,UAAC,CAAA;AAAA,UAClB,QAAA,EAAU,CACR,QAAA,KACG;AACH,YAAAA,SAAQ,QAAA,IAAYA,MAAAA;AAAA,UACtB;AAAA,SACF;AAEA,QAAA,MAAM,KAAA,GAAQ,MAAM,YAAA,CAAa,KAAA,CAAM,QAAQ,YAAY,CAAA;AAC3D,QAAA,IAAI,KAAA,EAAO,UAAU,MAAA,EAAW;AAC9B,UAAAA,MAAAA,GAAQ,MAAM,KAAA,IAASA,MAAAA;AAAA,QACzB;AAAA,MACF;AACA,MAAA,OAAOA,MAAAA;AAAA,IACT,CAAA;AAEA,IAAA,IAAI;AAEF,MAAA,MAAM,OAAA,GAAU,EAAE,GAAG,MAAA,CAAO,SAAS,GAAI,OAAA,CAAQ,OAAA,IAAW,EAAC,EAAG;AAChE,MAAA,IAAI,YAAA,CAAa,WAAA,IAAe,CAAC,OAAA,CAAQ,eAAe,CAAA,EAAG;AACzD,QAAA,OAAA,CAAQ,eAAe,CAAA,GAAI,CAAA,OAAA,EAAU,YAAA,CAAa,WAAW,CAAA,CAAA;AAAA,MAC/D;AAGA,MAAA,IAAI,YAAA,GAA4B;AAAA,QAC9B,MAAA;AAAA,QACA,MAAA;AAAA,QACA;AAAA,OACF;AAGA,MAAA,IAAI,YAAA,CAAa,SAAS,KAAA,CAAA,EAAW;AACnC,QAAA,IACE,OAAO,YAAA,CAAa,IAAA,KAAS,QAAA,IAC7B,YAAA,CAAa,SAAS,IAAA,EACtB;AACA,UAAA,YAAA,CAAa,IAAA,GAAO,aAAa,gBAAA,GAC7B,IAAA,CAAK,UAAU,YAAA,CAAa,IAAI,IAC/B,YAAA,CAAa,IAAA;AAAA,QACpB,CAAA,MAAO;AACL,UAAA,YAAA,CAAa,OAAO,YAAA,CAAa,IAAA;AAAA,QACnC;AAAA,MACF;AACA,MAAA,IAAI,aAAa,KAAA,KAAU,KAAA,CAAA;AACzB,QAAA,YAAA,CAAa,QAAQ,YAAA,CAAa,KAAA;AACpC,MAAA,IAAI,aAAa,WAAA,KAAgB,KAAA,CAAA;AAC/B,QAAA,YAAA,CAAa,cAAc,YAAA,CAAa,WAAA;AAC1C,MAAA,IAAI,YAAA,CAAa,eAAA,EAAiB,YAAA,CAAa,WAAA,GAAc,SAAA;AAC7D,MAAA,IAAI,aAAa,SAAA,KAAc,KAAA,CAAA;AAC7B,QAAA,YAAA,CAAa,YAAY,YAAA,CAAa,SAAA;AACxC,MAAA,IAAI,aAAa,SAAA,KAAc,KAAA,CAAA;AAC7B,QAAA,YAAA,CAAa,YAAY,YAAA,CAAa,SAAA;AACxC,MAAA,IAAI,aAAa,IAAA,KAAS,KAAA,CAAA;AACxB,QAAA,YAAA,CAAa,OAAO,YAAA,CAAa,IAAA;AACnC,MAAA,IAAI,aAAa,QAAA,KAAa,KAAA,CAAA;AAC5B,QAAA,YAAA,CAAa,WAAW,YAAA,CAAa,QAAA;AACvC,MAAA,IAAI,aAAa,QAAA,KAAa,KAAA,CAAA;AAC5B,QAAA,YAAA,CAAa,WAAW,YAAA,CAAa,QAAA;AACvC,MAAA,IAAI,aAAa,cAAA,KAAmB,KAAA,CAAA;AAClC,QAAA,YAAA,CAAa,iBAAiB,YAAA,CAAa,cAAA;AAE7C,MAAA,IAAI,QAAQ,OAAA,EAAS;AACnB,QAAA,OAAA,GAAU,QAAQ,OAAA,GAAU,GAAA;AAAA,MAC9B;AAEA,MAAA,MAAM,QAAA,GAAW,MAAM,KAAA,CAAM,OAAA,EAAS,YAAY,CAAA;AAElD,MAAA,IAAI,CAAC,SAAS,EAAA,EAAI;AAChB,QAAA,MAAM,kBAAkB,QAAA,CAAS,UAAA;AACjC,QAAA,IAAI,aAAA,GAAgB,eAAA;AAGpB,QAAA,IAAI,aAAa,YAAA,EAAc;AAE7B,UAAA,IAAI,YAAA,CAAa,YAAA,CAAa,QAAA,CAAS,MAAM,CAAA,EAAG;AAC9C,YAAA,aAAA,GAAgB,YAAA,CAAa,YAAA,CAAa,QAAA,CAAS,MAAM,CAAA;AAAA,UAC3D,CAAA,MAAO;AAEL,YAAA,KAAA,MAAW,CAAC,OAAA,EAAS,OAAO,CAAA,IAAK,MAAA,CAAO,OAAA;AAAA,cACtC,YAAA,CAAa;AAAA,aACf,EAAG;AACD,cAAA,IAAI,OAAO,YAAY,QAAA,EAAU;AAE/B,gBAAA,IAAI,OAAA,KAAY,QAAA,CAAS,MAAA,CAAO,QAAA,EAAS,EAAG;AAC1C,kBAAA,aAAA,GAAgB,OAAA;AAChB,kBAAA;AAAA,gBACF;AAEA,gBAAA,IACE,eAAA,CACG,WAAA,EAAY,CACZ,QAAA,CAAS,QAAQ,WAAA,EAAa,CAAA,IACjC,QAAA,CAAS,MAAA,CAAO,QAAA,EAAS,CAAE,QAAA,CAAS,OAAO,CAAA,EAC3C;AACA,kBAAA,aAAA,GAAgB,OAAA;AAChB,kBAAA;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,QAAA,KAAA,GAAQ,EAAE,OAAA,EAAS,aAAA,EAAe,MAAA,EAAQ,SAAS,MAAA,EAAO;AAC1D,QAAA,KAAA,GAAQ,MAAM,YAAY,KAAK,CAAA;AAAA,MACjC,CAAA,MAAO;AAEL,QAAA,MAAM,eAAA,GAAkB,SAAS,KAAA,EAAM;AACvC,QAAA,IAAA,GAAO,YAAA,CAAa,YAChB,MAAM,eAAA,CAAgB,MAAK,GAC3B,MAAM,gBAAgB,IAAA,EAAK;AAAA,MACjC;AAEA,MAAA,YAAA,CAAa,SAAS,CAAA;AACtB,MAAA,OAAA,GAAU,KAAA;AACV,MAAA,OAAO,EAAE,OAAA,EAAS,KAAA,EAAO,IAAA,EAAM,QAAA,EAAS;AAAA,IAC1C,SAAS,GAAA,EAAU;AACjB,MAAA,IAAI,gBAAgB,GAAA,CAAI,OAAA;AAGxB,MAAA,IAAI,aAAa,YAAA,EAAc;AAC7B,QAAA,KAAA,MAAW,CAAC,OAAA,EAAS,OAAO,CAAA,IAAK,MAAA,CAAO,OAAA;AAAA,UACtC,YAAA,CAAa;AAAA,SACf,EAAG;AACD,UAAA,IAAI,OAAO,YAAY,QAAA,EAAU;AAC/B,YAAA,IACE,IAAI,OAAA,CAAQ,WAAA,EAAY,CAAE,QAAA,CAAS,QAAQ,WAAA,EAAa,CAAA,IACxD,OAAA,CAAQ,aAAY,KAAM,eAAA,IAC1B,OAAA,CAAQ,WAAA,OAAkB,cAAA,EAC1B;AACA,cAAA,aAAA,GAAgB,OAAA;AAChB,cAAA;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,MAAA,KAAA,GAAQ,EAAE,OAAA,EAAS,aAAA,EAAe,MAAA,EAAQ,eAAA,EAAgB;AAC1D,MAAA,KAAA,GAAQ,MAAM,YAAY,KAAK,CAAA;AAC/B,MAAA,YAAA,CAAa,SAAS,CAAA;AACtB,MAAA,OAAA,GAAU,KAAA;AACV,MAAA,OAAO,EAAE,OAAA,EAAS,KAAA,EAAO,IAAA,EAAM,UAAU,IAAA,EAAK;AAAA,IAChD;AAAA,EACF,CAAA;AAEA,EAAA,MAAM,OAAA,GAAU,OACd,QAAA,KACiB;AACjB,IAAA,MAAM,OAAA,GAAU,MAAM,cAAA,EAAe;AACrC,IAAA,OAAO,QAAA,CAAS;AAAA,MACd,GAAG,OAAA;AAAA,MACH,OAAA;AAAA,MACA,aAAA;AAAA,MACA,YAAA;AAAA,MACA,WAAA;AAAA,MACA;AAAA,KACD,CAAA;AAAA,EACH,CAAA;AAEA,EAAA,MAAM,gBAAgB,MAAY;AAChC,IAAA,eAAA,CAAgB,KAAA,EAAM;AAAA,EACxB,CAAA;AAEA,EAAA,IAAI,MAAA,GAAS,MAAM,cAAA,EAAe;AAElC,EAAA,OAAO,OAAO,KAAA,IAAS,UAAA,GAAa,MAAA,CAAO,UAAA,IAAc,OAAO,KAAA,EAAO;AACrE,IAAA,UAAA,EAAA;AACA,IAAA,MAAA,GAAS,MAAM,cAAA,EAAe;AAAA,EAChC;AAEA,EAAA,IAAI,iBAAA,GAAgC,IAAA;AACpC,EAAA,IAAI,YAAA,GAAyD,IAAA;AAE7D,EAAA,MAAM,cAAc,MAAY;AAC9B,IAAA,IAAI,iBAAA,EAAmB;AACrB,MAAA,aAAA,CAAc,iBAAiB,CAAA;AAC/B,MAAA,iBAAA,GAAoB,IAAA;AAAA,IACtB;AAAA,EACF,CAAA;AAEA,EAAA,MAAM,kBAAA,GAAqB,CACzB,QAAA,KACS;AACT,IAAA,IAAI,OAAO,aAAa,UAAA,EAAY;AAClC,MAAA,MAAM,IAAI,MAAM,gDAAgD,CAAA;AAAA,IAClE;AACA,IAAA,YAAA,GAAe,QAAA;AAEf,IAAA,IAAI,MAAA,CAAO,YAAA,IAAgB,CAAC,iBAAA,EAAmB;AAC7C,MAAA,YAAA,EAAa;AAAA,IACf;AAAA,EACF,CAAA;AAEA,EAAA,MAAM,YAAA,GAAe,CAAC,QAAA,GAAmB,MAAA,CAAO,eAAA,KAA0B;AACxE,IAAA,IAAI,CAAC,YAAA,EAAc;AAEjB,MAAA,OAAA,CAAQ,KAAK,0DAA0D,CAAA;AACvE,MAAA;AAAA,IACF;AACA,IAAA,IAAI,iBAAA,EAAmB;AACrB,MAAA,WAAA,EAAY;AAAA,IACd;AACA,IAAA,iBAAA,GAAoB,YAAY,YAAY;AAC1C,MAAA,IAAI;AACF,QAAA,MAAM,SAAA,GAAY,MAAM,cAAA,EAAe;AACvC,QAAA,YAAA,CAAc,SAA0B,CAAA;AACxC,QAAA,MAAA,CAAO,MAAA,CAAO,QAAQ,SAAS,CAAA;AAAA,MACjC,SAAS,SAAA,EAAW;AAElB,QAAA,OAAA,CAAQ,KAAA,CAAM,kBAAkB,SAAS,CAAA;AAAA,MAC3C;AAAA,IACF,GAAG,QAAQ,CAAA;AAAA,EACb,CAAA;AAGA,EAAA,MAAM,iBAAiB,YAA6B;AAClD,IAAA,IAAI,CAAC,OAAO,QAAA,EAAU;AACpB,MAAA,MAAM,IAAI,MAAM,qCAAqC,CAAA;AAAA,IACvD;AACA,IAAA,IAAI,OAAO,MAAA,CAAO,QAAA,CAAS,IAAA,KAAS,UAAA,EAAY;AAC9C,MAAA,MAAM,IAAI,MAAM,0CAA0C,CAAA;AAAA,IAC5D;AACA,IAAA,IAAI;AACF,MAAA,OAAO,MAAM,MAAA,CAAO,QAAA,CAAS,IAAA,EAAK;AAAA,IACpC,CAAA,CAAA,MAAQ;AACN,MAAA,MAAM,IAAI,MAAM,iCAAiC,CAAA;AAAA,IACnD;AAAA,EACF,CAAA;AAEA,EAAA,MAAM,eAAe,YAA2B;AAC9C,IAAA,IAAI,CAAC,OAAO,QAAA,EAAU;AACpB,MAAA,MAAM,IAAI,MAAM,qCAAqC,CAAA;AAAA,IACvD;AACA,IAAA,IAAI,OAAO,MAAA,CAAO,QAAA,CAAS,IAAA,KAAS,UAAA,EAAY;AAC9C,MAAA,MAAM,IAAI,MAAM,0CAA0C,CAAA;AAAA,IAC5D;AACA,IAAA,IAAI;AACF,MAAA,OAAO,MAAM,MAAA,CAAO,QAAA,CAAS,IAAA,EAAK;AAAA,IACpC,CAAA,CAAA,MAAQ;AACN,MAAA,MAAM,IAAI,MAAM,iCAAiC,CAAA;AAAA,IACnD;AAAA,EACF,CAAA;AAEA,EAAA,MAAM,sBAAsB,YAAkC;AAC5D,IAAA,IAAI,CAAC,OAAO,QAAA,EAAU;AACpB,MAAA,MAAM,IAAI,MAAM,qCAAqC,CAAA;AAAA,IACvD;AACA,IAAA,IAAI,OAAO,MAAA,CAAO,QAAA,CAAS,WAAA,KAAgB,UAAA,EAAY;AACrD,MAAA,MAAM,IAAI,MAAM,0CAA0C,CAAA;AAAA,IAC5D;AACA,IAAA,IAAI;AACF,MAAA,OAAO,MAAM,MAAA,CAAO,QAAA,CAAS,WAAA,EAAY;AAAA,IAC3C,CAAA,CAAA,MAAQ;AACN,MAAA,MAAM,IAAI,MAAM,yCAAyC,CAAA;AAAA,IAC3D;AAAA,EACF,CAAA;AAEA,EAAA,MAAM,YAAA,GAAe,OACnB,QAAA,KACkB;AAClB,IAAA,IAAI,CAAC,OAAO,QAAA,EAAU;AACpB,MAAA,MAAM,IAAI,MAAM,qCAAqC,CAAA;AAAA,IACvD;AACA,IAAA,IAAI,CAAC,MAAA,CAAO,QAAA,CAAS,IAAA,EAAM;AACzB,MAAA,MAAM,IAAI,MAAM,0CAA0C,CAAA;AAAA,IAC5D;AAEA,IAAA,IAAI;AACF,MAAA,MAAM,MAAA,GAAS,MAAA,CAAO,QAAA,CAAS,IAAA,CAAK,SAAA,EAAU;AAC9C,MAAA,IAAI;AACF,QAAA,OAAO,IAAA,EAAM;AACX,UAAA,MAAM,EAAE,IAAA,EAAM,KAAA,EAAM,GAAI,MAAM,OAAO,IAAA,EAAK;AAC1C,UAAA,IAAI,IAAA,EAAM;AACV,UAAA,QAAA,CAAS,KAAK,CAAA;AAAA,QAChB;AAAA,MACF,CAAA,SAAE;AACA,QAAA,MAAA,CAAO,WAAA,EAAY;AAAA,MACrB;AAAA,IACF,CAAA,CAAA,MAAQ;AACN,MAAA,MAAM,IAAI,MAAM,gCAAgC,CAAA;AAAA,IAClD;AAAA,EACF,CAAA;AAGA,EAAA,MAAM,QAAA,GAAW,CAAA,EAAG,MAAM,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA;AACrC,EAAA,IAAI,OAAO,SAAA,IAAa,MAAA,KAAW,SAAS,KAAA,CAAM,GAAA,CAAI,QAAQ,CAAA,EAAG;AAC/D,IAAA,UAAA,CAAW,MAAM;AACf,MAAA,cAAA,EAAe,CAAE,IAAA,CAAK,CAAC,SAAA,KAAc;AACnC,QAAA,IAAI,CAAC,UAAU,KAAA,EAAO;AACpB,UAAA,KAAA,CAAM,IAAI,QAAA,EAAU;AAAA,YAClB,GAAG,SAAA;AAAA,YACH,OAAA;AAAA,YACA,aAAA;AAAA,YACA,YAAA;AAAA,YACA,WAAA;AAAA,YACA;AAAA,WACD,CAAA;AAAA,QACH;AAAA,MACF,CAAC,CAAA;AAAA,IACH,CAAA,EAAG,OAAO,eAAe,CAAA;AACzB,IAAA,OAAO,KAAA,CAAM,IAAI,QAAQ,CAAA;AAAA,EAC3B;AAGA,EAAA,IAAI,OAAO,SAAA,IAAa,MAAA,KAAW,KAAA,IAAS,CAAC,OAAO,KAAA,EAAO;AACzD,IAAA,KAAA,CAAM,IAAI,QAAA,EAAU;AAAA,MAClB,GAAG,MAAA;AAAA,MACH,OAAA;AAAA,MACA,aAAA;AAAA,MACA,YAAA;AAAA,MACA,WAAA;AAAA,MACA,kBAAA;AAAA,MACA,cAAA;AAAA,MACA,YAAA;AAAA,MACA,mBAAA;AAAA,MACA;AAAA,KACD,CAAA;AAAA,EACH;AAEA,EAAA,OAAO;AAAA,IACL,GAAG,MAAA;AAAA,IACH,OAAA;AAAA,IACA,aAAA;AAAA,IACA,YAAA;AAAA,IACA,WAAA;AAAA,IACA,kBAAA;AAAA,IACA,cAAA;AAAA,IACA,YAAA;AAAA,IACA,mBAAA;AAAA,IACA;AAAA,GACF;AACF;AAYO,SAAS,GAAA,CACd,KACA,OAAA,EACwB;AACxB,EAAA,OAAO,OAAA,CAAQ,GAAA,EAAK,KAAA,EAAO,OAAO,CAAA;AACpC;AAYO,SAAS,IAAA,CACd,KACA,OAAA,EACwB;AACxB,EAAA,OAAO,OAAA,CAAQ,GAAA,EAAK,MAAA,EAAQ,OAAO,CAAA;AACrC;AAYO,SAAS,GAAA,CACd,KACA,OAAA,EACwB;AACxB,EAAA,OAAO,OAAA,CAAQ,GAAA,EAAK,KAAA,EAAO,OAAO,CAAA;AACpC;AAYO,SAAS,MAAA,CACd,KACA,OAAA,EACwB;AACxB,EAAA,OAAO,OAAA,CAAQ,GAAA,EAAK,QAAA,EAAU,OAAO,CAAA;AACvC;AAcO,SAAS,KAAA,CACd,KACA,OAAA,EACwB;AACxB,EAAA,OAAO,OAAA,CAAQ,GAAA,EAAK,OAAA,EAAS,OAAO,CAAA;AACtC;AAgBO,SAAS,OAAA,CACd,KACA,OAAA,EACwB;AACxB,EAAA,OAAO,OAAA,CAAQ,GAAA,EAAK,SAAA,EAAW,OAAO,CAAA;AACxC;AAYO,SAAS,KAAA,CACd,KACA,OAAA,EACwB;AACxB,EAAA,OAAO,OAAA,CAAQ,GAAA,EAAK,OAAA,EAAS,OAAO,CAAA;AACtC;AAcO,SAAS,IAAA,CACd,KACA,OAAA,EACwB;AACxB,EAAA,OAAO,OAAA,CAAQ,GAAA,EAAK,MAAA,EAAQ,OAAO,CAAA;AACrC;AASO,SAAS,MAAA,CACd,GAAA,EACA,MAAA,EACA,OAAA,EACwB;AACxB,EAAA,OAAO,OAAA,CAAQ,GAAA,EAAK,MAAA,EAAQ,OAAO,CAAA;AACrC;AAuCO,SAAS,cAAA,CAAe,cAAA,GAAkC,EAAC,EAAG;AACnE,EAAA,MAAM,0BAAA,GAA6B,EAAE,GAAG,aAAA,EAAe,GAAG,cAAA,EAAe;AACzE,EAAA,MAAM,EAAE,SAAA,EAAW,UAAA,EAAY,SAAQ,GACrC,0BAAA,CAA2B,SAAS,EAAC;AAEvC,EAAA,MAAM,WAAA,GAAc,OAClB,MAAA,EACA,GAAA,EACA,OAAA,KAC2B;AAC3B,IAAA,IAAI,OAAA,GAAmB;AAAA,MACrB,MAAA,EAAQ,0BAAA;AAAA,MACR,OAAA,EAAS;AAAA,QACP,MAAA;AAAA,QACA,GAAA;AAAA,QACA,OAAA,EAAS;AAAA,UACP,GAAG,0BAAA;AAAA,UACH,GAAG,OAAA;AAAA,UACH,OAAA,EAAS;AAAA,YACP,GAAG,0BAAA,CAA2B,OAAA;AAAA,YAC9B,GAAI,OAAA,CAAQ,OAAA,IAAW;AAAC;AAC1B;AACF,OACF;AAAA,MACA,MAAA,EAAQ,IAAA;AAAA,MACR,KAAA,EAAO,IAAA;AAAA;AAAA,MAEP,UAAA,EAAY,CACV,OAAA,KAGG;AACH,QAAA,MAAM,cAAA,GAAiB,OAAA,CAAQ,OAAA,CAAQ,OAAA,CAAQ,WAAW,EAAC;AAC3D,QAAA,MAAMC,OAAAA,GAAS,QAAQ,cAAc,CAAA;AACrC,QAAA,IAAIA,OAAAA,EAAQ;AACV,UAAA,OAAA,CAAQ,OAAA,CAAQ,QAAQ,OAAA,GAAUA,OAAAA;AAAA,QACpC;AAAA,MACF,CAAA;AAAA,MACA,OAAA,EAAS,CAAC,IAAA,KAAc;AACtB,QAAA,OAAA,CAAQ,OAAA,CAAQ,QAAQ,IAAA,GAAO,IAAA;AAAA,MACjC,CAAA;AAAA,MACA,UAAA,EAAY,CACV,OAAA,KACG;AACH,QAAA,MAAMA,OAAAA,GAAS,OAAA,CAAQ,OAAA,CAAQ,OAAA,CAAQ,OAAO,CAAA;AAC9C,QAAA,IAAIA,OAAAA,EAAQ;AACV,UAAA,OAAA,CAAQ,QAAQ,OAAA,GAAUA,OAAAA;AAAA,QAC5B;AAAA,MACF,CAAA;AAAA,MACA,MAAA,EAAQ,CAACC,IAAAA,KAAgB;AACvB,QAAA,OAAA,CAAQ,QAAQ,GAAA,GAAMA,IAAAA;AAAA,MACxB,CAAA;AAAA,MACA,SAAA,EAAW,CAACC,OAAAA,KAAoB;AAC9B,QAAA,OAAA,CAAQ,QAAQ,MAAA,GAASA,OAAAA;AAAA,MAC3B,CAAA;AAAA,MACA,QAAA,EAAU,CACR,KAAA,KACG;AACH,QAAA,OAAA,CAAQ,KAAA,GAAQ,KAAA;AAAA,MAClB;AAAA,KACF;AAEA,IAAA,MAAM,UAAA,GAAa,CAAC,QAAA,EAAmBC,MAAAA,KAAiC;AACtE,MAAA,IAAI,CAACA,QAAO,OAAO,QAAA;AACnB,MAAA,MAAM,OAAA,GAAU;AAAA,QACd,GAAG,QAAA;AAAA,QACH,GAAGA,MAAAA;AAAA,QACH,OAAA,EAAS;AAAA,UACP,GAAG,QAAA,CAAS,OAAA;AAAA,UACZ,GAAGA,MAAAA,CAAM,OAAA;AAAA,UACT,OAAA,EAAS;AAAA,YACP,GAAG,SAAS,OAAA,CAAQ,OAAA;AAAA,YACpB,GAAGA,OAAM,OAAA,EAAS,OAAA;AAAA,YAClB,OAAA,EAAS;AAAA,cACP,GAAG,QAAA,CAAS,OAAA,CAAQ,OAAA,CAAQ,OAAA;AAAA,cAC5B,GAAIA,MAAAA,CAAM,OAAA,EAAS,OAAA,EAAS,WAAW;AAAC;AAC1C;AACF,SACF;AAAA,QACA,MAAA,EAAQA,MAAAA,CAAM,MAAA,IAAU,QAAA,CAAS,MAAA;AAAA,QACjC,KAAA,EAAOA,MAAAA,CAAM,KAAA,IAAS,QAAA,CAAS,KAAA;AAAA;AAAA,QAE/B,YAAY,QAAA,CAAS,UAAA;AAAA,QACrB,SAAS,QAAA,CAAS,OAAA;AAAA,QAClB,YAAY,QAAA,CAAS,UAAA;AAAA,QACrB,QAAQ,QAAA,CAAS,MAAA;AAAA,QACjB,WAAW,QAAA,CAAS,SAAA;AAAA,QACpB,UAAU,QAAA,CAAS;AAAA,OACrB;AAGA,MAAA,OAAA,CAAQ,UAAA,GAAa,CACnB,OAAA,KAGG;AACH,QAAA,MAAM,cAAA,GAAiB,OAAA,CAAQ,OAAA,CAAQ,OAAA,CAAQ,WAAW,EAAC;AAC3D,QAAA,MAAMH,OAAAA,GAAS,QAAQ,cAAc,CAAA;AACrC,QAAA,IAAIA,OAAAA,EAAQ;AACV,UAAA,OAAA,CAAQ,OAAA,CAAQ,QAAQ,OAAA,GAAUA,OAAAA;AAAA,QACpC;AAAA,MACF,CAAA;AACA,MAAA,OAAA,CAAQ,OAAA,GAAU,CAAC,IAAA,KAAc;AAC/B,QAAA,OAAA,CAAQ,OAAA,CAAQ,QAAQ,IAAA,GAAO,IAAA;AAAA,MACjC,CAAA;AACA,MAAA,OAAA,CAAQ,UAAA,GAAa,CACnB,OAAA,KACG;AACH,QAAA,MAAMA,OAAAA,GAAS,OAAA,CAAQ,OAAA,CAAQ,OAAA,CAAQ,OAAO,CAAA;AAC9C,QAAA,IAAIA,OAAAA,EAAQ;AACV,UAAA,OAAA,CAAQ,QAAQ,OAAA,GAAUA,OAAAA;AAAA,QAC5B;AAAA,MACF,CAAA;AACA,MAAA,OAAA,CAAQ,MAAA,GAAS,CAACC,IAAAA,KAAgB;AAChC,QAAA,OAAA,CAAQ,QAAQ,GAAA,GAAMA,IAAAA;AAAA,MACxB,CAAA;AACA,MAAA,OAAA,CAAQ,SAAA,GAAY,CAACC,OAAAA,KAAoB;AACvC,QAAA,OAAA,CAAQ,QAAQ,MAAA,GAASA,OAAAA;AAAA,MAC3B,CAAA;AACA,MAAA,OAAA,CAAQ,QAAA,GAAW,CACjB,KAAA,KACG;AACH,QAAA,OAAA,CAAQ,KAAA,GAAQ,KAAA;AAAA,MAClB,CAAA;AAEA,MAAA,OAAO,OAAA;AAAA,IACT,CAAA;AAGA,IAAA,IAAI,SAAA,EAAW;AACb,MAAA,MAAMC,MAAAA,GAAQ,MAAM,SAAA,CAAU,OAAO,CAAA;AACrC,MAAA,IAAIA,MAAAA,EAAO;AACT,QAAA,OAAA,GAAU,UAAA,CAAW,SAASA,MAAK,CAAA;AAAA,MACrC;AAAA,IACF;AAIA,IAAA,MAAM,MAAA,GAAS,MAAM,OAAA,CAAQ,OAAA,CAAQ,QAAQ,GAAA,EAAK,OAAA,CAAQ,QAAQ,MAAA,EAAQ;AAAA,MACxE,GAAG,QAAQ,OAAA,CAAQ,OAAA;AAAA,MACnB,KAAA,EAAO,EAAE,OAAA;AAAQ,KAClB,CAAA;AAED,IAAA,OAAA,CAAQ,MAAA,GAAS,MAAA;AAEjB,IAAA,IAAI,UAAA,EAAY;AACd,MAAA,MAAMA,MAAAA,GAAQ,MAAM,UAAA,CAAW,OAAO,CAAA;AACtC,MAAA,IAAIA,MAAAA,EAAO;AACT,QAAA,OAAA,GAAU,UAAA,CAAW,SAASA,MAAK,CAAA;AAAA,MACrC;AAAA,IACF;AAEA,IAAA,OAAO,OAAA,CAAQ,MAAA;AAAA,EACjB,CAAA;AAEA,EAAA,MAAM,YAAA,GAAe,CAAC,MAAA,KAAoB;AACxC,IAAA,OAAO,CAAC,KAAa,OAAA,KACnB,WAAA,CAAY,QAAQ,GAAA,EAAK,OAAA,IAAW,EAAE,CAAA;AAAA,EAC1C,CAAA;AAEA,EAAA,MAAM,GAAA,GAAM,aAAa,KAAK,CAAA;AAC9B,EAAA,MAAM,IAAA,GAAO,aAAa,MAAM,CAAA;AAChC,EAAA,MAAM,GAAA,GAAM,aAAa,KAAK,CAAA;AAC9B,EAAA,MAAM,OAAA,GAAU,aAAa,QAAQ,CAAA;AACrC,EAAA,MAAM,KAAA,GAAQ,aAAa,OAAO,CAAA;AAClC,EAAA,MAAM,QAAA,GAAW,aAAa,SAAS,CAAA;AACvC,EAAA,MAAM,KAAA,GAAQ,aAAa,OAAO,CAAA;AAClC,EAAA,MAAM,IAAA,GAAO,aAAa,MAAM,CAAA;AAChC,EAAA,MAAM,MAAA,GAAS,CAAC,GAAA,EAAa,MAAA,EAAgB,OAAA,KAC3C,YAAY,MAAA,EAAmB,GAAA,EAAK,OAAA,IAAW,EAAE,CAAA;AACnD,EAAA,MAAM,cAAA,GAAiB,CAAC,KAAA,KAAkB;AACxC,IAAA,0BAAA,CAA2B,WAAA,GAAc,KAAA;AACzC,IAAA,0BAAA,CAA2B,OAAA,CAAQ,eAAe,CAAA,GAAI,CAAA,OAAA,EAAU,KAAK,CAAA,CAAA;AAAA,EACvE,CAAA;AAEA,EAAA,OAAO;AAAA,IACL,GAAA;AAAA,IACA,IAAA;AAAA,IACA,GAAA;AAAA,IACA,MAAA,EAAQ,OAAA;AAAA,IACR,KAAA;AAAA,IACA,OAAA,EAAS,QAAA;AAAA,IACT,KAAA;AAAA,IACA,IAAA;AAAA,IACA,MAAA;AAAA,IACA,OAAA,EAAS;AAAA,MACP,WAAW,MAAM,0BAAA;AAAA,MACjB;AAAA;AACF,GACF;AACF","file":"index.js","sourcesContent":["/**\n * Supported HTTP methods for z-fetch requests.\n * Includes standard HTTP methods and support for custom methods.\n */\nexport type METHODS =\n  | \"GET\"\n  | \"POST\"\n  | \"PUT\"\n  | \"DELETE\"\n  | \"PATCH\"\n  | \"OPTIONS\"\n  | \"TRACE\"\n  | \"HEAD\"\n  | \"CUSTOM\"\n  | string;\n\n/**\n * Utility type for making all properties of an object optional recursively.\n * Used internally for partial context updates in hooks.\n */\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n/**\n * Hook function type for intercepting and modifying requests/responses.\n * Hooks can be synchronous or asynchronous and can return partial context updates.\n *\n * @param context - The current request/response context\n * @returns A partial context update object or void\n *\n * @example\n * ```typescript\n * const requestHook: Hook = async (context) => {\n *   // Add custom header\n *   context.setHeaders(headers => ({ ...headers, 'X-Custom': 'value' }));\n *\n *   // Or return a partial update\n *   return {\n *     request: {\n *       options: {\n *         headers: { ...context.request.options.headers, 'X-Custom': 'value' }\n *       }\n *     }\n *   };\n * };\n * ```\n */\nexport type Hook = (\n  context: Context,\n) => Promise<DeepPartial<Context> | void> | DeepPartial<Context> | void;\n\n/**\n * Context object passed to hooks containing request/response information and helper methods.\n * Provides access to configuration, request details, response data, and utility functions.\n *\n * @example\n * ```typescript\n * const onRequest: Hook = (context) => {\n *   // Access current request\n *   console.log(context.request.method, context.request.url);\n *\n *   // Use helper methods\n *   context.setHeaders(headers => ({ ...headers, 'Authorization': 'Bearer token' }));\n *   context.setBody({ timestamp: Date.now() });\n * };\n * ```\n */\nexport type Context = {\n  /** Current z-fetch configuration */\n  config: Config;\n  /** Request information including method, URL, and options */\n  request: {\n    method: METHODS;\n    url: string;\n    options: RequestOptions;\n  };\n  /** Response result (null during onRequest hook) */\n  result: RequestResult | null;\n  /** Error information (null if no error occurred) */\n  error: { message: string; status: string | number } | null;\n\n  // Helper methods for easier manipulation\n  /** Helper method to update request headers */\n  setHeaders: (\n    updater: (headers: {\n      [key: string]: string;\n    }) => { [key: string]: string } | void,\n  ) => void;\n  /** Helper method to update request body */\n  setBody: (body: any) => void;\n  /** Helper method to update request options */\n  setOptions: (\n    updater: (options: RequestOptions) => RequestOptions | void,\n  ) => void;\n  /** Helper method to update request URL */\n  setUrl: (url: string) => void;\n  /** Helper method to update request method */\n  setMethod: (method: METHODS) => void;\n  /** Helper method to update error information */\n  setError: (\n    error: { message: string; status: string | number } | null,\n  ) => void;\n};\n\n/**\n * Configuration object for z-fetch instances and requests.\n * Defines default behaviors, authentication, hooks, and other options.\n *\n * @example\n * ```typescript\n * const config: Config = {\n *   baseUrl: 'https://api.example.com',\n *   bearerToken: 'your-token',\n *   headers: { 'Content-Type': 'application/json' },\n *   hooks: {\n *     onRequest: (context) => {\n *       context.setHeaders(headers => ({ ...headers, 'X-Timestamp': Date.now().toString() }));\n *     },\n *     onError: (context) => {\n *       console.error('Request failed:', context.error);\n *     }\n *   },\n *   onUploadProgress: (event) => {\n *     console.log(`Upload: ${event.loaded}/${event.total}`);\n *   }\n * };\n * ```\n */\nexport type Config = {\n  /** Base URL to prepend to all request URLs */\n  baseUrl: string;\n  /** Bearer token for automatic Authorization header */\n  bearerToken: string | null;\n  /** Request timeout in milliseconds */\n  timeout: number;\n  /** Whether to enable automatic retries on failure */\n  retry: boolean;\n  /** Maximum number of retry attempts */\n  maxRetries: number;\n  /** Whether to start polling immediately after request */\n  startPolling: boolean;\n  /** Whether to stop any active polling */\n  stopPolling: boolean;\n  /** Interval between polling requests in milliseconds */\n  pollingInterval: number;\n  /** Cache revalidation interval in milliseconds */\n  revalidateCache: number;\n  /** Whether to include credentials in requests */\n  withCredentials: boolean;\n  /** Whether to enable response caching for GET requests */\n  withCache: boolean;\n  /** Whether to automatically parse JSON responses */\n  parseJson: boolean;\n  /** Whether to automatically stringify request payload */\n  stringifyPayload: boolean;\n  /** CORS mode for the request */\n  mode: RequestMode;\n  /** Default headers to include with all requests */\n  headers: { [key: string]: string };\n  /** Hook functions for request/response/error interception */\n  hooks: {\n    /** Called before sending the request */\n    onRequest?: Hook;\n    /** Called after receiving the response */\n    onResponse?: Hook;\n    /** Called when an error occurs */\n    onError?: Hook;\n  };\n  /** Mapping of status codes/patterns to custom error messages */\n  errorMapping?: {\n    [statusCode: number]: string;\n    [statusPattern: string]: string;\n  };\n  /** Callback for upload progress tracking */\n  onUploadProgress?: (event: ProgressEvent) => void;\n  /** Callback for download progress tracking */\n  onDownloadProgress?: (event: ProgressEvent) => void;\n  /** Force XMLHttpRequest when progress callbacks are provided */\n  useXHRForProgress?: boolean;\n};\n\n/**\n * Result object returned by z-fetch requests containing response data and utility methods.\n * Provides access to response data, error information, and various control methods.\n *\n * @example\n * ```typescript\n * const result = await api.get('/users');\n *\n * if (result.error) {\n *   console.error('Request failed:', result.error.message);\n * } else {\n *   console.log('Users:', result.data);\n *\n *   // Stream response data\n *   const text = await result.streamToString();\n *\n *   // Start polling for updates\n *   result.onPollDataReceived((newResult) => {\n *     console.log('Updated data:', newResult.data);\n *   });\n *   result.startPolling(5000);\n * }\n * ```\n */\nexport type RequestResult = {\n  /** Whether the request is currently loading */\n  loading: boolean;\n  /** Error information if the request failed */\n  error: { message: string; status: string | number } | null;\n  /** Response data (parsed JSON or raw text based on parseJson config) */\n  data: any;\n  /** Raw Response object from fetch API */\n  response: Response | null;\n  /** Method to refetch the same request */\n  refetch: (callback: (result: RequestResult) => void) => Promise<any>;\n  /** Method to cancel the ongoing request */\n  cancelRequest: () => void;\n  /** Method to start polling for updates */\n  startPolling: (interval?: number) => void;\n  /** Method to stop active polling */\n  stopPolling: () => void;\n  /** Method to set callback for polling data updates */\n  onPollDataReceived: (callback: (result: RequestResult) => void) => void;\n\n  // Streaming utilities\n  /** Stream response body as string */\n  streamToString?: () => Promise<string>;\n  /** Stream response body as Blob */\n  streamToBlob?: () => Promise<Blob>;\n  /** Stream response body as ArrayBuffer */\n  streamToArrayBuffer?: () => Promise<ArrayBuffer>;\n  /** Stream response body chunk by chunk */\n  streamChunks?: (callback: (chunk: Uint8Array) => void) => Promise<void>;\n};\n\n/**\n * Request options for z-fetch requests.\n * Extends standard RequestInit while allowing object bodies and partial Config options.\n *\n * @example\n * ```typescript\n * const options: RequestOptions = {\n *   body: { name: 'John', age: 30 }, // Will be JSON.stringify'd if stringifyPayload is true\n *   headers: { 'X-Custom': 'value' },\n *   timeout: 10000,\n *   bearerToken: 'override-token',\n *   onUploadProgress: (event) => console.log(`Progress: ${event.loaded}/${event.total}`)\n * };\n *\n * const result = await api.post('/users', options);\n * ```\n */\nexport type RequestOptions = Omit<RequestInit, \"body\"> & {\n  /** Request body - can be object (will be stringified), string, or any BodyInit */\n  body?: BodyInit | object | null;\n} & Partial<Config>;\n\n/**\n * Default configuration object for z-fetch.\n * Provides sensible defaults for all configuration options.\n * Can be overridden globally or per-instance.\n *\n * @example\n * ```typescript\n * // Global config override\n * Object.assign(defaultConfig, {\n *   baseUrl: 'https://api.myapp.com',\n *   timeout: 60000\n * });\n *\n * // Or use createInstance for per-instance config\n * const api = createInstance({\n *   ...defaultConfig,\n *   bearerToken: 'my-token'\n * });\n * ```\n */\nexport const defaultConfig: Config = {\n  baseUrl: \"\",\n  bearerToken: null,\n  timeout: 90000,\n  retry: false,\n  maxRetries: 3,\n  startPolling: false,\n  stopPolling: false,\n  pollingInterval: 5000,\n  revalidateCache: 10000,\n  withCredentials: false,\n  withCache: true,\n  parseJson: true,\n  stringifyPayload: true,\n  mode: \"cors\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n    Accept: \"*/*\",\n  },\n  hooks: {},\n  errorMapping: {},\n  useXHRForProgress: false,\n};\n\nlet config: Config = { ...defaultConfig };\n\n/**\n * Internal cache for storing GET request results.\n * Used when withCache is enabled to avoid duplicate requests.\n */\nconst cache: Map<string, RequestResult> = new Map();\n\n/**\n * Performs HTTP request using XMLHttpRequest for progress tracking support.\n * Used internally when upload/download progress callbacks are provided.\n *\n * @param url - The request URL\n * @param method - HTTP method to use\n * @param options - Request options and configuration\n * @param context - Additional context for error handling\n * @returns Promise resolving to basic request result\n *\n * @internal\n */\nasync function requestWithProgress(\n  url: string,\n  method: METHODS,\n  options: RequestOptions = { ...defaultConfig },\n  context?: { config: Config; onError?: Hook },\n): Promise<{\n  loading: boolean;\n  error: { message: string; status: string | number } | null;\n  data: any;\n  response: Response | null;\n}> {\n  return new Promise((resolve) => {\n    const mergedConfig = { ...config, ...options };\n    let fullUrl = mergedConfig.baseUrl ? mergedConfig.baseUrl + url : url;\n\n    const xhr = new XMLHttpRequest();\n\n    // Setup upload progress tracking\n    if (mergedConfig.onUploadProgress && xhr.upload) {\n      xhr.upload.addEventListener(\"progress\", mergedConfig.onUploadProgress);\n    }\n\n    // Setup download progress tracking\n    if (mergedConfig.onDownloadProgress) {\n      xhr.addEventListener(\"progress\", mergedConfig.onDownloadProgress);\n    }\n\n    const handleError = async (error: {\n      message: string;\n      status: string | number;\n    }) => {\n      if (context?.onError && context.config) {\n        const errorContext = {\n          config: context.config,\n          request: {\n            method,\n            url,\n            options: mergedConfig,\n          },\n          result: null,\n          error,\n          setHeaders: () => {},\n          setBody: () => {},\n          setOptions: () => {},\n          setUrl: () => {},\n          setMethod: () => {},\n          setError: (\n            newError: { message: string; status: string | number } | null,\n          ) => {\n            error = newError || error;\n          },\n        };\n\n        const patch = await context.onError(errorContext);\n        if (patch?.error !== undefined) {\n          error = patch.error || error;\n        }\n      }\n      return error;\n    };\n\n    xhr.addEventListener(\"loadend\", async () => {\n      let error: { message: string; status: string | number } | null = null;\n      let data: any = null;\n      let response: Response | null = null;\n\n      if (xhr.status >= 200 && xhr.status < 300) {\n        try {\n          data = mergedConfig.parseJson\n            ? JSON.parse(xhr.responseText)\n            : xhr.responseText;\n          // Create a mock Response object for compatibility\n          response = {\n            ok: true,\n            status: xhr.status,\n            statusText: xhr.statusText,\n            url: fullUrl,\n            headers: new Headers(),\n            json: async () =>\n              mergedConfig.parseJson\n                ? JSON.parse(xhr.responseText)\n                : xhr.responseText,\n            text: async () => xhr.responseText,\n            blob: async () => new Blob([xhr.response]),\n            arrayBuffer: async () => xhr.response,\n            formData: async () => new FormData(),\n            body: null,\n            bodyUsed: false,\n            clone: function () {\n              return this;\n            },\n            type: \"basic\",\n            redirected: false,\n          } as Response;\n        } catch {\n          error = {\n            message: \"Failed to parse response\",\n            status: \"PARSE_ERROR\",\n          };\n          error = await handleError(error);\n        }\n      } else {\n        const originalMessage = xhr.statusText;\n        let mappedMessage = originalMessage;\n\n        // Apply error mapping if configured\n        if (mergedConfig.errorMapping) {\n          // Check for exact status code match\n          if (mergedConfig.errorMapping[xhr.status]) {\n            mappedMessage = mergedConfig.errorMapping[xhr.status];\n          } else {\n            // Check for pattern matches\n            for (const [pattern, message] of Object.entries(\n              mergedConfig.errorMapping,\n            )) {\n              if (typeof pattern === \"string\") {\n                if (pattern === xhr.status.toString()) {\n                  mappedMessage = message;\n                  break;\n                }\n                if (\n                  originalMessage\n                    .toLowerCase()\n                    .includes(pattern.toLowerCase()) ||\n                  xhr.status.toString().includes(pattern)\n                ) {\n                  mappedMessage = message;\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        error = { message: mappedMessage, status: xhr.status };\n        error = await handleError(error);\n      }\n\n      resolve({ loading: false, error, data, response });\n    });\n\n    xhr.addEventListener(\"error\", async () => {\n      let mappedMessage = \"Network error\";\n\n      // Apply error mapping for network errors if configured\n      if (mergedConfig.errorMapping) {\n        for (const [pattern, message] of Object.entries(\n          mergedConfig.errorMapping,\n        )) {\n          if (typeof pattern === \"string\") {\n            if (\n              pattern.toLowerCase() === \"network_error\" ||\n              pattern.toLowerCase() === \"fetch failed\"\n            ) {\n              mappedMessage = message;\n              break;\n            }\n          }\n        }\n      }\n\n      let error: { message: string; status: string | number } = {\n        message: mappedMessage,\n        status: \"NETWORK_ERROR\",\n      };\n      const handledError = await handleError(error);\n      error = handledError || error;\n\n      resolve({\n        loading: false,\n        error,\n        data: null,\n        response: null,\n      });\n    });\n\n    xhr.addEventListener(\"timeout\", async () => {\n      let error: { message: string; status: string | number } = {\n        message: \"Request timed out!\",\n        status: \"TIMEOUT\",\n      };\n      const handledError = await handleError(error);\n      error = handledError || error;\n\n      resolve({\n        loading: false,\n        error,\n        data: null,\n        response: null,\n      });\n    });\n\n    // Setup the request\n    xhr.open(method, fullUrl);\n    xhr.timeout = mergedConfig.timeout;\n\n    // Set headers\n    const headers = { ...config.headers, ...(options.headers || {}) };\n    if (mergedConfig.bearerToken && !headers[\"Authorization\"]) {\n      headers[\"Authorization\"] = `Bearer ${mergedConfig.bearerToken}`;\n    }\n\n    Object.entries(headers).forEach(([key, value]) => {\n      xhr.setRequestHeader(key, String(value));\n    });\n\n    // Set credentials\n    if (mergedConfig.withCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    // Send the request\n    let body: any = null;\n    if (mergedConfig.body !== undefined) {\n      if (typeof mergedConfig.body === \"object\" && mergedConfig.body !== null) {\n        body = mergedConfig.stringifyPayload\n          ? JSON.stringify(mergedConfig.body)\n          : mergedConfig.body;\n      } else {\n        body = mergedConfig.body;\n      }\n    }\n\n    xhr.send(body);\n  });\n}\n\n/**\n * Core request function that handles HTTP requests using fetch API or XMLHttpRequest.\n * Provides comprehensive error handling, retries, caching, polling, and streaming support.\n * Automatically switches to XMLHttpRequest when progress tracking is needed.\n *\n * @param url - The request URL (can be relative if baseUrl is configured)\n * @param method - HTTP method to use\n * @param options - Request options and configuration overrides\n * @returns Promise resolving to RequestResult with response data and utilities\n *\n * @internal\n */\nasync function request(\n  url: string,\n  method: METHODS,\n  options: RequestOptions = { ...defaultConfig },\n): Promise<RequestResult> {\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  let loading = true;\n  let error: { message: string; status: string | number } | null = null;\n  let data: any = null;\n  let retryCount = 0;\n\n  // Merge configuration properly\n  const mergedConfig = { ...config, ...options };\n  let fullUrl = mergedConfig.baseUrl ? mergedConfig.baseUrl + url : url;\n\n  // Check if we should use XMLHttpRequest for progress tracking\n  const shouldUseXHR =\n    mergedConfig.useXHRForProgress ||\n    mergedConfig.onUploadProgress ||\n    mergedConfig.onDownloadProgress;\n\n  const timeoutId = setTimeout(() => {\n    abortController.abort();\n    loading = true;\n    error = { message: \"Request timed out!\", status: \"TIMEOUT\" };\n  }, mergedConfig.timeout);\n\n  const performRequest = async (): Promise<{\n    loading: boolean;\n    error: typeof error;\n    data: any;\n    response: Response | null;\n  }> => {\n    // Use XMLHttpRequest if progress tracking is needed\n    if (shouldUseXHR) {\n      return await requestWithProgress(url, method, options, {\n        config: mergedConfig,\n        onError: mergedConfig.hooks?.onError,\n      });\n    }\n\n    const handleError = async (error: {\n      message: string;\n      status: string | number;\n    }) => {\n      if (mergedConfig.hooks?.onError) {\n        const errorContext = {\n          config: mergedConfig,\n          request: {\n            method,\n            url,\n            options: mergedConfig,\n          },\n          result: null,\n          error,\n          setHeaders: () => {},\n          setBody: () => {},\n          setOptions: () => {},\n          setUrl: () => {},\n          setMethod: () => {},\n          setError: (\n            newError: { message: string; status: string | number } | null,\n          ) => {\n            error = newError || error;\n          },\n        };\n\n        const patch = await mergedConfig.hooks.onError(errorContext);\n        if (patch?.error !== undefined) {\n          error = patch.error || error;\n        }\n      }\n      return error;\n    };\n\n    try {\n      // Handle bearerToken option - but don't override explicit Authorization header\n      const headers = { ...config.headers, ...(options.headers || {}) };\n      if (mergedConfig.bearerToken && !headers[\"Authorization\"]) {\n        headers[\"Authorization\"] = `Bearer ${mergedConfig.bearerToken}`;\n      }\n\n      // Only pass valid fetch options, excluding z-fetch specific config\n      let fetchOptions: RequestInit = {\n        signal,\n        method,\n        headers,\n      };\n\n      // Add valid fetch options from merged config\n      if (mergedConfig.body !== undefined) {\n        if (\n          typeof mergedConfig.body === \"object\" &&\n          mergedConfig.body !== null\n        ) {\n          fetchOptions.body = mergedConfig.stringifyPayload\n            ? JSON.stringify(mergedConfig.body)\n            : (mergedConfig.body as BodyInit);\n        } else {\n          fetchOptions.body = mergedConfig.body as BodyInit;\n        }\n      }\n      if (mergedConfig.cache !== undefined)\n        fetchOptions.cache = mergedConfig.cache;\n      if (mergedConfig.credentials !== undefined)\n        fetchOptions.credentials = mergedConfig.credentials;\n      if (mergedConfig.withCredentials) fetchOptions.credentials = \"include\";\n      if (mergedConfig.integrity !== undefined)\n        fetchOptions.integrity = mergedConfig.integrity;\n      if (mergedConfig.keepalive !== undefined)\n        fetchOptions.keepalive = mergedConfig.keepalive;\n      if (mergedConfig.mode !== undefined)\n        fetchOptions.mode = mergedConfig.mode;\n      if (mergedConfig.redirect !== undefined)\n        fetchOptions.redirect = mergedConfig.redirect;\n      if (mergedConfig.referrer !== undefined)\n        fetchOptions.referrer = mergedConfig.referrer;\n      if (mergedConfig.referrerPolicy !== undefined)\n        fetchOptions.referrerPolicy = mergedConfig.referrerPolicy;\n\n      if (options.baseUrl) {\n        fullUrl = options.baseUrl + url;\n      }\n\n      const response = await fetch(fullUrl, fetchOptions);\n\n      if (!response.ok) {\n        const originalMessage = response.statusText;\n        let mappedMessage = originalMessage;\n\n        // Apply error mapping if configured\n        if (mergedConfig.errorMapping) {\n          // Check for exact status code match\n          if (mergedConfig.errorMapping[response.status]) {\n            mappedMessage = mergedConfig.errorMapping[response.status];\n          } else {\n            // Check for pattern matches\n            for (const [pattern, message] of Object.entries(\n              mergedConfig.errorMapping,\n            )) {\n              if (typeof pattern === \"string\") {\n                // Check if status code matches pattern\n                if (pattern === response.status.toString()) {\n                  mappedMessage = message;\n                  break;\n                }\n                // Check if original message contains pattern (case insensitive)\n                if (\n                  originalMessage\n                    .toLowerCase()\n                    .includes(pattern.toLowerCase()) ||\n                  response.status.toString().includes(pattern)\n                ) {\n                  mappedMessage = message;\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        error = { message: mappedMessage, status: response.status };\n        error = await handleError(error);\n      } else {\n        // Clone response for data extraction to preserve body for streaming utilities\n        const responseForData = response.clone();\n        data = mergedConfig.parseJson\n          ? await responseForData.json()\n          : await responseForData.text();\n      }\n\n      clearTimeout(timeoutId);\n      loading = false;\n      return { loading, error, data, response };\n    } catch (err: any) {\n      let mappedMessage = err.message;\n\n      // Apply error mapping for network errors if configured\n      if (mergedConfig.errorMapping) {\n        for (const [pattern, message] of Object.entries(\n          mergedConfig.errorMapping,\n        )) {\n          if (typeof pattern === \"string\") {\n            if (\n              err.message.toLowerCase().includes(pattern.toLowerCase()) ||\n              pattern.toLowerCase() === \"network_error\" ||\n              pattern.toLowerCase() === \"fetch failed\"\n            ) {\n              mappedMessage = message;\n              break;\n            }\n          }\n        }\n      }\n\n      error = { message: mappedMessage, status: \"NETWORK_ERROR\" };\n      error = await handleError(error);\n      clearTimeout(timeoutId);\n      loading = false;\n      return { loading, error, data, response: null };\n    }\n  };\n\n  const refetch = async (\n    callback: (result: RequestResult) => void,\n  ): Promise<any> => {\n    const newData = await performRequest();\n    return callback({\n      ...newData,\n      refetch,\n      cancelRequest,\n      startPolling,\n      stopPolling,\n      onPollDataReceived,\n    });\n  };\n\n  const cancelRequest = (): void => {\n    abortController.abort();\n  };\n\n  let result = await performRequest();\n\n  while (config.retry && retryCount < config.maxRetries && result.error) {\n    retryCount++;\n    result = await performRequest();\n  }\n\n  let pollingIntervalId: any | null = null;\n  let pollCallback: ((result: RequestResult) => void) | null = null;\n\n  const stopPolling = (): void => {\n    if (pollingIntervalId) {\n      clearInterval(pollingIntervalId);\n      pollingIntervalId = null;\n    }\n  };\n\n  const onPollDataReceived = (\n    callback: (result: RequestResult) => void,\n  ): void => {\n    if (typeof callback !== \"function\") {\n      throw new Error(\"onPollDataReceived callback must be a function\");\n    }\n    pollCallback = callback;\n    // Start polling if it was requested but delayed due to missing callback\n    if (config.startPolling && !pollingIntervalId) {\n      startPolling();\n    }\n  };\n\n  const startPolling = (interval: number = config.pollingInterval): void => {\n    if (!pollCallback) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Polling not started: onPollDataReceived callback not set\");\n      return;\n    }\n    if (pollingIntervalId) {\n      stopPolling(); // Clear existing interval if any\n    }\n    pollingIntervalId = setInterval(async () => {\n      try {\n        const newResult = await performRequest();\n        pollCallback!(newResult as RequestResult);\n        Object.assign(result, newResult);\n      } catch (pollError) {\n        // eslint-disable-next-line no-console\n        console.error(\"Polling error:\", pollError);\n      }\n    }, interval);\n  };\n\n  // Streaming utility functions\n  const streamToString = async (): Promise<string> => {\n    if (!result.response) {\n      throw new Error(\"No response available for streaming\");\n    }\n    if (typeof result.response.text !== \"function\") {\n      throw new Error(\"No response body available for streaming\");\n    }\n    try {\n      return await result.response.text();\n    } catch {\n      throw new Error(\"Failed to read response as text\");\n    }\n  };\n\n  const streamToBlob = async (): Promise<Blob> => {\n    if (!result.response) {\n      throw new Error(\"No response available for streaming\");\n    }\n    if (typeof result.response.blob !== \"function\") {\n      throw new Error(\"No response body available for streaming\");\n    }\n    try {\n      return await result.response.blob();\n    } catch {\n      throw new Error(\"Failed to read response as blob\");\n    }\n  };\n\n  const streamToArrayBuffer = async (): Promise<ArrayBuffer> => {\n    if (!result.response) {\n      throw new Error(\"No response available for streaming\");\n    }\n    if (typeof result.response.arrayBuffer !== \"function\") {\n      throw new Error(\"No response body available for streaming\");\n    }\n    try {\n      return await result.response.arrayBuffer();\n    } catch {\n      throw new Error(\"Failed to read response as array buffer\");\n    }\n  };\n\n  const streamChunks = async (\n    callback: (chunk: Uint8Array) => void,\n  ): Promise<void> => {\n    if (!result.response) {\n      throw new Error(\"No response available for streaming\");\n    }\n    if (!result.response.body) {\n      throw new Error(\"No response body available for streaming\");\n    }\n\n    try {\n      const reader = result.response.body.getReader();\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n          callback(value);\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    } catch {\n      throw new Error(\"Failed to read response stream\");\n    }\n  };\n\n  // Check cache for GET requests\n  const cacheKey = `${method}:${fullUrl}`;\n  if (config.withCache && method === \"GET\" && cache.has(cacheKey)) {\n    setTimeout(() => {\n      performRequest().then((newResult) => {\n        if (!newResult.error) {\n          cache.set(cacheKey, {\n            ...newResult,\n            refetch,\n            cancelRequest,\n            startPolling,\n            stopPolling,\n            onPollDataReceived,\n          });\n        }\n      });\n    }, config.revalidateCache);\n    return cache.get(cacheKey)!;\n  }\n\n  // Cache successful GET requests\n  if (config.withCache && method === \"GET\" && !result.error) {\n    cache.set(cacheKey, {\n      ...result,\n      refetch,\n      cancelRequest,\n      startPolling,\n      stopPolling,\n      onPollDataReceived,\n      streamToString,\n      streamToBlob,\n      streamToArrayBuffer,\n      streamChunks,\n    });\n  }\n\n  return {\n    ...result,\n    refetch,\n    cancelRequest,\n    startPolling,\n    stopPolling,\n    onPollDataReceived,\n    streamToString,\n    streamToBlob,\n    streamToArrayBuffer,\n    streamChunks,\n  };\n}\n\n/**\n * Sends an HTTP GET request to the specified URL.\n *\n * @param url - The target URL to send the GET request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await GET('https://api.example.com/resource');\n */\nexport function GET(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"GET\", options);\n}\n\n/**\n * Sends an HTTP POST request to the specified URL.\n *\n * @param url - The target URL to send the POST request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await POST('https://api.example.com/resource', { body: { key: 'value' } });\n */\nexport function POST(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"POST\", options);\n}\n\n/**\n * Sends an HTTP PUT request to the specified URL.\n *\n * @param url - The target URL to send the PUT request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await PUT('https://api.example.com/resource', { body: { key: 'value' } });\n */\nexport function PUT(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"PUT\", options);\n}\n\n/**\n * Sends an HTTP DELETE request to the specified URL.\n *\n * @param url - The target URL to send the DELETE request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * const result = await DELETE('https://api.example.com/resource');\n */\nexport function DELETE(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"DELETE\", options);\n}\n\n/**\n * Sends an HTTP PATCH request to the specified URL.\n *\n * @param url - The target URL to send the PATCH request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n *\n * const result = await PATCH('https://api.example.com/resource', { body: { key: 'value' } });\n *\n */\nexport function PATCH(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"PATCH\", options);\n}\n\n// Additional HTTP methods\n\n/**\n * Sends an HTTP OPTIONS request to the specified URL.\n *\n * @param url - The target URL to send the OPTIONS request to\n * @param options - Optional configuration options for the request\n * @returns A Promise that resolves to the request result\n *\n * @example\n * ```ts\n * const result = await OPTIONS('https://api.example.com/resource');\n * ```\n */\nexport function OPTIONS(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"OPTIONS\", options);\n}\n\n/**\n * Sends a TRACE request to the specified URL.\n *\n * The TRACE method performs a message loop-back test along the path to the target resource.\n *\n * @param url - The URL to send the TRACE request to\n * @param options - Optional request configuration options\n * @returns A Promise that resolves to the response from the request\n * @throws {Error} If the request fails or network error occurs\n */\nexport function TRACE(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"TRACE\", options);\n}\n\n/**\n * Performs an HTTP HEAD request to the specified URL.\n *\n * @param url - The URL to send the HEAD request to\n * @param options - Optional configuration for the request\n * @returns A Promise that resolves with the response data\n *\n * @example\n * ```typescript\n * const result = await HEAD('https://api.example.com/resource');\n * ```\n */\nexport function HEAD(\n  url: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, \"HEAD\", options);\n}\n\n/**\n * CUSTOM method allows you to specify any HTTP method.\n * @param {string} url - The URL to request\n * @param {string} method - The HTTP method (e.g. \"CONNECT\", \"CUSTOM\", etc.)\n * @param {RequestOptions} [options] - Additional options for the request\n * @returns {Promise<RequestResult>} The request result\n */\nexport function CUSTOM(\n  url: string,\n  method: string,\n  options?: RequestOptions,\n): Promise<RequestResult> {\n  return request(url, method, options);\n}\n\n/**\n * Creates a new Z-Fetch instance with custom configuration.\n *\n * @param instanceConfig - Optional configuration object to override default settings\n * @returns An object containing HTTP methods (get, post, etc.) and helper utilities\n *\n * @example\n * ```typescript\n * // Create a new instance with custom config\n * const api = createInstance({\n *   baseUrl: 'https://api.example.com',\n *   headers: { 'Content-Type': 'application/json' },\n *   hooks: {\n *     // Modify request before sending\n *     onRequest: (context) => {\n *       context.request.options.headers['X-Custom-Header'] = 'value';\n *       return context;\n *     },\n *\n *     // Modify response after receiving\n *     onResponse: (context) => {\n *       context.result.data = {\n *         ...context.result.data,\n *         customData: 'value'\n *       };\n *       return context;\n *     }\n *   }\n * });\n *\n * // Make HTTP requests\n * const data = await api.get('/users');\n *\n * // Use Helpers, eg. access instance configuration\n * const config = api.helpers.getConfig();\n * ```\n */\nexport function createInstance(instanceConfig: Partial<Config> = {}) {\n  const instanceConfigWithDefaults = { ...defaultConfig, ...instanceConfig };\n  const { onRequest, onResponse, onError } =\n    instanceConfigWithDefaults.hooks || {};\n\n  const interceptor = async (\n    method: METHODS,\n    url: string,\n    options: RequestOptions,\n  ): Promise<RequestResult> => {\n    let context: Context = {\n      config: instanceConfigWithDefaults,\n      request: {\n        method,\n        url,\n        options: {\n          ...instanceConfigWithDefaults,\n          ...options,\n          headers: {\n            ...instanceConfigWithDefaults.headers,\n            ...(options.headers || {}),\n          },\n        },\n      },\n      result: null,\n      error: null,\n      // Helper methods for easier manipulation\n      setHeaders: (\n        updater: (headers: {\n          [key: string]: string;\n        }) => { [key: string]: string } | void,\n      ) => {\n        const currentHeaders = context.request.options.headers || {};\n        const result = updater(currentHeaders);\n        if (result) {\n          context.request.options.headers = result;\n        }\n      },\n      setBody: (body: any) => {\n        context.request.options.body = body;\n      },\n      setOptions: (\n        updater: (options: RequestOptions) => RequestOptions | void,\n      ) => {\n        const result = updater(context.request.options);\n        if (result) {\n          context.request.options = result;\n        }\n      },\n      setUrl: (url: string) => {\n        context.request.url = url;\n      },\n      setMethod: (method: METHODS) => {\n        context.request.method = method;\n      },\n      setError: (\n        error: { message: string; status: string | number } | null,\n      ) => {\n        context.error = error;\n      },\n    };\n\n    const applyPatch = (original: Context, patch?: DeepPartial<Context>) => {\n      if (!patch) return original;\n      const updated = {\n        ...original,\n        ...patch,\n        request: {\n          ...original.request,\n          ...patch.request,\n          options: {\n            ...original.request.options,\n            ...patch.request?.options,\n            headers: {\n              ...original.request.options.headers,\n              ...(patch.request?.options?.headers || {}),\n            },\n          },\n        },\n        result: patch.result ?? original.result,\n        error: patch.error ?? original.error,\n        // Preserve helper methods\n        setHeaders: original.setHeaders,\n        setBody: original.setBody,\n        setOptions: original.setOptions,\n        setUrl: original.setUrl,\n        setMethod: original.setMethod,\n        setError: original.setError,\n      } as Context;\n\n      // Update the helper methods to work with the new context\n      updated.setHeaders = (\n        updater: (headers: {\n          [key: string]: string;\n        }) => { [key: string]: string } | void,\n      ) => {\n        const currentHeaders = updated.request.options.headers || {};\n        const result = updater(currentHeaders);\n        if (result) {\n          updated.request.options.headers = result;\n        }\n      };\n      updated.setBody = (body: any) => {\n        updated.request.options.body = body;\n      };\n      updated.setOptions = (\n        updater: (options: RequestOptions) => RequestOptions | void,\n      ) => {\n        const result = updater(updated.request.options);\n        if (result) {\n          updated.request.options = result;\n        }\n      };\n      updated.setUrl = (url: string) => {\n        updated.request.url = url;\n      };\n      updated.setMethod = (method: METHODS) => {\n        updated.request.method = method;\n      };\n      updated.setError = (\n        error: { message: string; status: string | number } | null,\n      ) => {\n        updated.error = error;\n      };\n\n      return updated;\n    };\n\n    // console.log('context log before::', context.request.options);\n    if (onRequest) {\n      const patch = await onRequest(context);\n      if (patch) {\n        context = applyPatch(context, patch);\n      }\n    }\n\n    // console.log('context log after::', context.request.options);\n\n    const result = await request(context.request.url, context.request.method, {\n      ...context.request.options,\n      hooks: { onError },\n    });\n\n    context.result = result;\n\n    if (onResponse) {\n      const patch = await onResponse(context);\n      if (patch) {\n        context = applyPatch(context, patch);\n      }\n    }\n\n    return context.result!;\n  };\n\n  const createMethod = (method: METHODS) => {\n    return (url: string, options?: RequestOptions) =>\n      interceptor(method, url, options || {});\n  };\n\n  const get = createMethod(\"GET\");\n  const post = createMethod(\"POST\");\n  const put = createMethod(\"PUT\");\n  const delete_ = createMethod(\"DELETE\");\n  const patch = createMethod(\"PATCH\");\n  const options_ = createMethod(\"OPTIONS\");\n  const trace = createMethod(\"TRACE\");\n  const head = createMethod(\"HEAD\");\n  const custom = (url: string, method: string, options?: RequestOptions) =>\n    interceptor(method as METHODS, url, options || {});\n  const setBearerToken = (token: string) => {\n    instanceConfigWithDefaults.bearerToken = token;\n    instanceConfigWithDefaults.headers[\"Authorization\"] = `Bearer ${token}`;\n  };\n\n  return {\n    get,\n    post,\n    put,\n    delete: delete_,\n    patch,\n    options: options_,\n    trace,\n    head,\n    custom,\n    helpers: {\n      getConfig: () => instanceConfigWithDefaults,\n      setBearerToken,\n    },\n  };\n}\n"]}